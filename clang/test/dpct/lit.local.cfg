# -*- Python -*- vim: set ft=python ts=4 sw=4 expandtab tw=79:
import os
import re
import sys
import platform
import subprocess
import shutil

def is_string_in_file(file_path, search_string):
    with open(file_path, "r", encoding='ISO-8859-1') as file:
        if search_string in file.read():
            return True
    return False

# Insert skip when the cudnn.h and nccl.h header file not found.
def get_case_with_string(search_text):
    current_dir = config.test_source_root
    test_cases = []
    for root, dirs, files in os.walk(current_dir):
        for filename in files:
            file_path = os.path.join(root, filename)
            if is_string_in_file(file_path, search_text):
                test_cases.append(file_path[file_path.rfind("/")+1: ])
    return test_cases

def run_sanity(case = ""):
    out_root_path = os.path.join(config.test_source_root, "dpct", "dpct_out")
    dpct_cmd = os.path.join(config.llvm_tools_dir, "dpct") + " " + \
             os.path.join(config.test_source_root, "dpct", case) + \
             " --cuda-include-path=" + os.path.join(cuda_path, "include") + \
             " --out-root=" + out_root_path
    run_on_shell = False
    if platform.system() == 'Linux':
        run_on_shell = True
    complete_process = subprocess.run(dpct_cmd, shell=run_on_shell, check=False,
                    stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
                    encoding="utf-8", timeout=120)
    if os.path.exists(out_root_path):
        shutil.rmtree(out_root_path)
    return complete_process

# Get CUDA installation path from environment variable CUDA_PATH,
# if $CUDA_PATH not found, default is '/usr/local/cuda'
cuda_path = os.path.abspath(os.environ.get('CUDA_PATH', '/usr/local/cuda'))

# Get real location if CUDA path is a symbolic link
if os.path.islink(cuda_path):
    sys.stderr.write("CUDA PATH: " + cuda_path)
    # TODO: Call os.path.realpath(...) for all platforms when Python 3.8 is required.
    # The bug of os.path.realpath(...) on Windows was fixed in Python 3.8.
    # See https://docs.python.org/3.10/library/os.path.html#os.path.realpath
    if platform.system() in ['Windows']:
        link_path = os.readlink(cuda_path)
    else:
        link_path = os.path.realpath(cuda_path)

    if os.path.isabs(link_path):
        cuda_path = os.path.abspath(link_path)
    else:
        # link path is a relative path, eg: /usr/local/cuda -> cuda-8.0
        # Get full path
        # Eg: [ cuda_path, link_path ] = [ '/usr/local/cuda', 'cuda-8.0' ]
        # cuda_path = dirname('/usr/local/cuda/' + '/../') + 'cuda-8.0'
        cuda_path = os.path.join(os.path.dirname(cuda_path + '/../'), link_path)

    sys.stderr.write(" => " + cuda_path + "\n")

cuda_found = False

# Check CUDA path is valid
if not os.path.exists(cuda_path):
    sys.stderr.write("No CUDA installation found in CUDA PATH: " + \
                     cuda_path + "\n")

    # Check whether CUDA 8.0 exists
    default_cuda_8_path = os.path.abspath("/usr/local/cuda-8.0")
    if os.path.exists("/usr/local/cuda-8.0"):
        sys.stderr.write("Default CUDA installation found in CUDA PATH: " + \
                         default_cuda_8_path + "\n")
        cuda_path = default_cuda_8_path
        cuda_found = True
    else:
        sys.stderr.write("Please set environment CUDA_PATH to correct path " \
                         "or make a symbolic link to \"/usr/local/cuda\"\n")
else:
    # Retrieve version from CUDA path
    if platform.system() in ['Linux']:
        version = re.search(r'.*cuda.*[\d.]+.*', os.path.basename(cuda_path))
    else:
        version = re.search(r'.*v.*[\d.]+.*', os.path.basename(cuda_path))
    if not version:
        sys.stderr.write("No CUDA version found in CUDA PATH: " + \
                         cuda_path + "\n")
    else:
        cuda_found = True

if cuda_found:
    config.available_features.add(os.path.basename(cuda_path))

    # Replace string '%cuda-path' found under current directory with
    # cuda_path above
    config.substitutions.append(('%cuda-path', cuda_path))
else:
    config.unsupported = True

# Run the dpct sanity test.
if not config.unsupported:
    test_cases = ["cudnn_sanity.cu", "nccl_sanity.cu"]
    complete_process = run_sanity("cudnn_sanity.cu")
    err_message = ""
    if complete_process.returncode != 0:
        if "'cudnn.h' file not found" in complete_process.stdout:
            err_message += "'cudnn.h' header file not found in platform. " + \
                          "Please make sure install the header file of cuDNN and " + \
                          "export cudnn.h in CPATH\n"
            test_cases.extend(get_case_with_string("cudnn.h"))
    complete_process = run_sanity("nccl_sanity.cu")
    if complete_process.returncode != 0:
        if "'nccl.h' file not found" in complete_process.stdout:
            err_message += "'nccl.h' header file not found in platform. " + \
                          "Please make sure install the header file of NCCL and " + \
                          "export nccl.h in CPATH.\n"
            test_cases.extend(get_case_with_string("nccl.h"))
    if (err_message):
        sys.stderr.write(err_message)
    config.excludes =test_cases