/* -*- coding: utf-8 -*-
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
*/

/**
 * This file implements a shared library. This library can be pre-loaded by
 * the dynamic linker of the Operating System (OS). It implements a few function
 * related to process creation. By pre-load this library the executed process
 * uses these functions instead of those from the standard library.
 *
 * The idea here is to inject a logic before call the real methods. The logic is
 * to dump the call into a file. To call the real method this library is doing
 * the job of the dynamic linker.
 *
 * The only input for the log writing is about the destination directory.
 * This is passed as environment variable.
 */

// NOLINTNEXTLINE
#include "config.h"

#include <dlfcn.h>
#include <pthread.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#if defined HAVE_POSIX_SPAWN || defined HAVE_POSIX_SPAWNP
#include <spawn.h>
#endif

#if defined HAVE_NSGETENVIRON
#include <crt_externs.h>
#else
extern char **environ;
#endif
#define SYCLomatic_CUSTOMIZATION

#define ENV_OUTPUT "INTERCEPT_BUILD_TARGET_DIR"
#ifdef APPLE
#define ENV_FLAT "DYLD_FORCE_FLAT_NAMESPACE"
#define ENV_PRELOAD "DYLD_INSERT_LIBRARIES"
#define ENV_SIZE 3
#else
#define ENV_PRELOAD "LD_PRELOAD"
#define ENV_SIZE 2
#endif

#ifdef SYCLomatic_CUSTOMIZATION
#include <ctype.h>
#define PATH_MAX 4096
#endif // SYCLomatic_CUSTOMIZATION

#define DLSYM(TYPE_, VAR_, SYMBOL_)                                            \
  union {                                                                      \
    void *from;                                                                \
    TYPE_ to;                                                                  \
  } cast;                                                                      \
  if (0 == (cast.from = dlsym(RTLD_NEXT, SYMBOL_))) {                          \
    perror("bear: dlsym");                                                     \
    exit(EXIT_FAILURE);                                                        \
  }                                                                            \
  TYPE_ const VAR_ = cast.to;

typedef char const *bear_env_t[ENV_SIZE];

static int bear_capture_env_t(bear_env_t *env);
static int bear_reset_env_t(bear_env_t *env);
static void bear_release_env_t(bear_env_t *env);
static char const **bear_update_environment(char *const envp[],
                                            bear_env_t *env);
static char const **bear_update_environ(char const **in, char const *key,
                                        char const *value);
static char **bear_get_environment();
#ifdef SYCLomatic_CUSTOMIZATION
static int bear_report_call(char const *fun, char const *argv[]);
#else
static void bear_report_call(char const *fun, char const *const argv[]);
#endif // SYCLomatic_CUSTOMIZATION
static char const **bear_strings_build(char const *arg, va_list *ap);
static char const **bear_strings_copy(char const **const in);
static char const **bear_strings_append(char const **in, char const *e);
static size_t bear_strings_length(char const *const *in);
static void bear_strings_release(char const **);

static bear_env_t env_names = {ENV_OUTPUT, ENV_PRELOAD
#ifdef ENV_FLAT
                               ,
                               ENV_FLAT
#endif
};

static bear_env_t initial_env = {0, 0
#ifdef ENV_FLAT
                                 ,
                                 0
#endif
};

static int initialized = 0;
static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

static void on_load(void) __attribute__((constructor));
static void on_unload(void) __attribute__((destructor));

#ifdef HAVE_EXECVE
static int call_execve(const char *path, char *const argv[],
                       char *const envp[]);
#endif
#ifdef HAVE_EXECVP
static int call_execvp(const char *file, char *const argv[]);
#endif
#ifdef HAVE_EXECVPE
static int call_execvpe(const char *file, char *const argv[],
                        char *const envp[]);
#endif
#ifdef HAVE_EXECVP2
static int call_execvP(const char *file, const char *search_path,
                       char *const argv[]);
#endif
#ifdef HAVE_EXECT
static int call_exect(const char *path, char *const argv[], char *const envp[]);
#endif
#ifdef HAVE_POSIX_SPAWN
static int call_posix_spawn(pid_t *restrict pid, const char *restrict path,
                            const posix_spawn_file_actions_t *file_actions,
                            const posix_spawnattr_t *restrict attrp,
                            char *const argv[restrict],
                            char *const envp[restrict]);
#endif
#ifdef HAVE_POSIX_SPAWNP
static int call_posix_spawnp(pid_t *restrict pid, const char *restrict file,
                             const posix_spawn_file_actions_t *file_actions,
                             const posix_spawnattr_t *restrict attrp,
                             char *const argv[restrict],
                             char *const envp[restrict]);
#endif

/* Initialization method to Captures the relevant environment variables.
 */

static void on_load(void) {
  pthread_mutex_lock(&mutex);
  if (!initialized)
    initialized = bear_capture_env_t(&initial_env);
  pthread_mutex_unlock(&mutex);
}

static void on_unload(void) {
  pthread_mutex_lock(&mutex);
  bear_release_env_t(&initial_env);
  initialized = 0;
  pthread_mutex_unlock(&mutex);
}

/* These are the methods we are try to hijack.
 */

#ifdef HAVE_EXECVE
int execve(const char *path, char *const argv[], char *const envp[]) {
#ifdef SYCLomatic_CUSTOMIZATION
  int ret = bear_report_call(__func__, (char const **)argv);
  if (ret)
    path = argv[0];
#else
  bear_report_call(__func__, (char const *const *)argv);
#endif // SYCLomatic_CUSTOMIZATION
  return call_execve(path, argv, envp);
}
#endif

#ifdef HAVE_EXECV
#ifndef HAVE_EXECVE
#error can not implement execv without execve
#endif
int execv(const char *path, char *const argv[]) {
#ifdef SYCLomatic_CUSTOMIZATION
  int ret = bear_report_call(__func__, (char const **)argv);
  if (ret)
    path = argv[0];
#else
  bear_report_call(__func__, (char const *const *)argv);
#endif // SYCLomatic_CUSTOMIZATION
  char *const *envp = bear_get_environment();
  return call_execve(path, argv, envp);
}
#endif

#ifdef HAVE_EXECVPE
int execvpe(const char *file, char *const argv[], char *const envp[]) {
#ifdef SYCLomatic_CUSTOMIZATION
  int ret = bear_report_call(__func__, (char const **)argv);
  // To sync file name with argv[0], in case argv[0] is changed
  // by bear_report_call.
  if (ret)
    file = argv[0];
#else
  bear_report_call(__func__, (char const *const *)argv);
#endif // SYCLomatic_CUSTOMIZATION
  return call_execvpe(file, argv, envp);
}
#endif

#ifdef HAVE_EXECVP
int execvp(const char *file, char *const argv[]) {
#ifdef SYCLomatic_CUSTOMIZATION
  int ret = bear_report_call(__func__, (char const **)argv);
  // To sync file name with argv[0], in case argv[0] is changed
  // by bear_report_call.
  if (ret)
    file = argv[0];
#else
  bear_report_call(__func__, (char const *const *)argv);
#endif // SYCLomatic_CUSTOMIZATION
  return call_execvp(file, argv);
}
#endif

#ifdef HAVE_EXECVP2
int execvP(const char *file, const char *search_path, char *const argv[]) {
#ifdef SYCLomatic_CUSTOMIZATION
  int ret = bear_report_call(__func__, (char const **)argv);
  // To sync file name with argv[0], in case argv[0] is changed
  // by bear_report_call.
  if (ret)
    file = argv[0];
#else
  bear_report_call(__func__, (char const *const *)argv);
#endif // SYCLomatic_CUSTOMIZATION
  return call_execvP(file, search_path, argv);
}
#endif

#ifdef HAVE_EXECT
int exect(const char *path, char *const argv[], char *const envp[]) {
#ifdef SYCLomatic_CUSTOMIZATION
  int ret = bear_report_call(__func__, (char const **)argv);
  if (ret)
    path = argv[0];
#else
  bear_report_call(__func__, (char const *const *)argv);
#endif // SYCLomatic_CUSTOMIZATION
  return call_exect(path, argv, envp);
}
#endif

#ifdef HAVE_EXECL
#ifndef HAVE_EXECVE
#error can not implement execl without execve
#endif
int execl(const char *path, const char *arg, ...) {
  va_list args;
  va_start(args, arg);
  char const **argv = bear_strings_build(arg, &args);
  va_end(args);

#ifdef SYCLomatic_CUSTOMIZATION
  int ret = bear_report_call(__func__, (char const **)argv);
  if (ret)
    path = argv[0];
#else
  bear_report_call(__func__, (char const *const *)argv);
#endif // SYCLomatic_CUSTOMIZATION
  char *const *envp = bear_get_environment();
  int const result = call_execve(path, (char *const *)argv, envp);

  bear_strings_release(argv);
  return result;
}
#endif

#ifdef HAVE_EXECLP
#ifndef HAVE_EXECVP
#error can not implement execlp without execvp
#endif
int execlp(const char *file, const char *arg, ...) {
  va_list args;
  va_start(args, arg);
  char const **argv = bear_strings_build(arg, &args);
  va_end(args);

#ifdef SYCLomatic_CUSTOMIZATION
  int ret = bear_report_call(__func__, (char const **)argv);
  if (ret)
    file = argv[0];
#else
  bear_report_call(__func__, (char const *const *)argv);
#endif // SYCLomatic_CUSTOMIZATION
  int const result = call_execvp(file, (char *const *)argv);

  bear_strings_release(argv);
  return result;
}
#endif

#ifdef HAVE_EXECLE
#ifndef HAVE_EXECVE
#error can not implement execle without execve
#endif
// int execle(const char *path, const char *arg, ..., char * const envp[]);
int execle(const char *path, const char *arg, ...) {
  va_list args;
  va_start(args, arg);
  char const **argv = bear_strings_build(arg, &args);
  char const **envp = va_arg(args, char const **);
  va_end(args);

#ifdef SYCLomatic_CUSTOMIZATION
  int ret = bear_report_call(__func__, (char const **)argv);
  if (ret)
    path = argv[0];
#else
  bear_report_call(__func__, (char const *const *)argv);
#endif // SYCLomatic_CUSTOMIZATION
  int const result =
      call_execve(path, (char *const *)argv, (char *const *)envp);

  bear_strings_release(argv);
  return result;
}
#endif

#ifdef HAVE_POSIX_SPAWN
int posix_spawn(pid_t *restrict pid, const char *restrict path,
                const posix_spawn_file_actions_t *file_actions,
                const posix_spawnattr_t *restrict attrp,
                char *const argv[restrict], char *const envp[restrict]) {
#ifdef SYCLomatic_CUSTOMIZATION
  int ret = bear_report_call(__func__, (char const **)argv);
  if (ret)
    path = argv[0];
#else
  bear_report_call(__func__, (char const *const *)argv);
#endif // SYCLomatic_CUSTOMIZATION
  return call_posix_spawn(pid, path, file_actions, attrp, argv, envp);
}
#endif

#ifdef HAVE_POSIX_SPAWNP
int posix_spawnp(pid_t *restrict pid, const char *restrict file,
                 const posix_spawn_file_actions_t *file_actions,
                 const posix_spawnattr_t *restrict attrp,
                 char *const argv[restrict], char *const envp[restrict]) {
#ifdef SYCLomatic_CUSTOMIZATION
  bear_report_call(__func__, (char const **)argv);
#else
  bear_report_call(__func__, (char const *const *)argv);
#endif // SYCLomatic_CUSTOMIZATION
  return call_posix_spawnp(pid, file, file_actions, attrp, argv, envp);
}
#endif

/* These are the methods which forward the call to the standard implementation.
 */

#ifdef HAVE_EXECVE
static int call_execve(const char *path, char *const argv[],
                       char *const envp[]) {
  typedef int (*func)(const char *, char *const *, char *const *);

  DLSYM(func, fp, "execve");

  char const **const menvp = bear_update_environment(envp, &initial_env);
  int const result = (*fp)(path, argv, (char *const *)menvp);
  bear_strings_release(menvp);
  return result;
}
#endif

#ifdef HAVE_EXECVPE
static int call_execvpe(const char *file, char *const argv[],
                        char *const envp[]) {
  typedef int (*func)(const char *, char *const *, char *const *);

  DLSYM(func, fp, "execvpe");

  char const **const menvp = bear_update_environment(envp, &initial_env);
  int const result = (*fp)(file, argv, (char *const *)menvp);
  bear_strings_release(menvp);
  return result;
}
#endif

#ifdef HAVE_EXECVP
static int call_execvp(const char *file, char *const argv[]) {
  typedef int (*func)(const char *file, char *const argv[]);

  DLSYM(func, fp, "execvp");

  bear_env_t current_env;
  bear_capture_env_t(&current_env);
  bear_reset_env_t(&initial_env);
  int const result = (*fp)(file, argv);
  bear_reset_env_t(&current_env);
  bear_release_env_t(&current_env);

  return result;
}
#endif

#ifdef HAVE_EXECVP2
static int call_execvP(const char *file, const char *search_path,
                       char *const argv[]) {
  typedef int (*func)(const char *, const char *, char *const *);

  DLSYM(func, fp, "execvP");

  bear_env_t current_env;
  bear_capture_env_t(&current_env);
  bear_reset_env_t(&initial_env);
  int const result = (*fp)(file, search_path, argv);
  bear_reset_env_t(&current_env);
  bear_release_env_t(&current_env);

  return result;
}
#endif

#ifdef HAVE_EXECT
static int call_exect(const char *path, char *const argv[],
                      char *const envp[]) {
  typedef int (*func)(const char *, char *const *, char *const *);

  DLSYM(func, fp, "exect");

  char const **const menvp = bear_update_environment(envp, &initial_env);
  int const result = (*fp)(path, argv, (char *const *)menvp);
  bear_strings_release(menvp);
  return result;
}
#endif

#ifdef HAVE_POSIX_SPAWN
static int call_posix_spawn(pid_t *restrict pid, const char *restrict path,
                            const posix_spawn_file_actions_t *file_actions,
                            const posix_spawnattr_t *restrict attrp,
                            char *const argv[restrict],
                            char *const envp[restrict]) {
  typedef int (*func)(pid_t *restrict, const char *restrict,
                      const posix_spawn_file_actions_t *,
                      const posix_spawnattr_t *restrict, char *const *restrict,
                      char *const *restrict);

  DLSYM(func, fp, "posix_spawn");

  char const **const menvp = bear_update_environment(envp, &initial_env);
  int const result =
      (*fp)(pid, path, file_actions, attrp, argv, (char *const *restrict)menvp);
  bear_strings_release(menvp);
  return result;
}
#endif

#ifdef HAVE_POSIX_SPAWNP
static int call_posix_spawnp(pid_t *restrict pid, const char *restrict file,
                             const posix_spawn_file_actions_t *file_actions,
                             const posix_spawnattr_t *restrict attrp,
                             char *const argv[restrict],
                             char *const envp[restrict]) {
  typedef int (*func)(pid_t *restrict, const char *restrict,
                      const posix_spawn_file_actions_t *,
                      const posix_spawnattr_t *restrict, char *const *restrict,
                      char *const *restrict);

  DLSYM(func, fp, "posix_spawnp");

  char const **const menvp = bear_update_environment(envp, &initial_env);
  int const result =
      (*fp)(pid, file, file_actions, attrp, argv, (char *const *restrict)menvp);
  bear_strings_release(menvp);
  return result;
}
#endif

#ifdef SYCLomatic_CUSTOMIZATION

/*
* The content of g_data[] comes from hex dump of file foo.a,
* where foo.c is a empty file. It comes from the following steps
* $gcc foo.c -c foo.o
* $ar cr foo.a foo.o
* $hexdump foo.a
*
* foo.a is used to pass the check of tool ranlib, which is used to generate
* an index to speed access to archives of static library.
*/
const unsigned char g_data[] = {
    0x21,       0x3c,       0x61,       0x72, 0x63, 0x68, 0x3e, 0xa,  0x2f,
    0x20,       0x20,       0x20,       0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x20,       0x20,       0x20,       0x20, 0x20, 0x20, 0x30, 0x20, 0x20,
    0x20,       0x20,       0x20,       0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x30,       0x20,       0x20,       0x20, 0x20, 0x20, 0x30, 0x20, 0x20,
    0x20,       0x20,       0x20,       0x30, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x20,       0x20,       0x34,       0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x20,       0x20,       0x20,       0x60, 0xa,  0x0,  0x0,  0x0,  0x0,
    0x74,       0x65,       0x73,       0x74, 0x2e, 0x6f, 0x2f, 0x20, 0x20,
    0x20,       0x20,       0x20,       0x20, 0x20, 0x20, 0x20, 0x30, 0x20,
    0x20,       0x20,       0x20,       0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x20,       0x30,       0x20,       0x20, 0x20, 0x20, 0x20, 0x30, 0x20,
    0x20,       0x20,       0x20,       0x20, 0x36, 0x34, 0x34, 0x20, 0x20,
    0x20,       0x20,       0x20,       0x31, 0x30, 0x37, 0x32, 0x20, 0x20,
    0x20,       0x20,       0x20,       0x20, 0x60, 0xa,  0x7f, 0x45, 0x4c,
    0x46,       0x2,        0x1,        0x1,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x1,  0x0,  0x3e, 0x0,  0x1,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0xb0,       0x1,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x40, 0x0,  0x0,  0x0,  0x0,
    0x0,        0x40,       0x0,        0xa,  0x0,  0x9,  0x0,  0x0,  0x47,
    0x43,       0x43,       0x3a,       0x20, 0x28, 0x55, 0x62, 0x75, 0x6e,
    0x74,       0x75,       0x20,       0x39, 0x2e, 0x33, 0x2e, 0x30, 0x2d,
    0x31,       0x37,       0x75,       0x62, 0x75, 0x6e, 0x74, 0x75, 0x31,
    0x7e,       0x32,       0x30,       0x2e, 0x30, 0x34, 0x29, 0x20, 0x39,
    0x2e,       0x33,       0x2e,       0x30, 0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x4,        0x0,        0x0,  0x0,  0x10, 0x0,  0x0,  0x0,
    0x5,        0x0,        0x0,        0x0,  0x47, 0x4e, 0x55, 0x0,  0x2,
    0x0,        0x0,        0xc0,       0x4,  0x0,  0x0,  0x0,  0x3,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x1,  0x0,  0x0,  0x0,  0x4,  0x0,
    0xf1,       0xff,       0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x3,  0x0,  0x1,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x3,        0x0,        0x2,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x3,  0x0,
    0x3,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x3,  0x0,  0x5,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x3,        0x0,        0x6,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x3,  0x0,
    0x4,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x74,       0x65,       0x73, 0x74, 0x2e, 0x63, 0x0,  0x0,
    0x2e,       0x73,       0x79,       0x6d, 0x74, 0x61, 0x62, 0x0,  0x2e,
    0x73,       0x74,       0x72,       0x74, 0x61, 0x62, 0x0,  0x2e, 0x73,
    0x68,       0x73,       0x74,       0x72, 0x74, 0x61, 0x62, 0x0,  0x2e,
    0x74,       0x65,       0x78,       0x74, 0x0,  0x2e, 0x64, 0x61, 0x74,
    0x61,       0x0,        0x2e,       0x62, 0x73, 0x73, 0x0,  0x2e, 0x63,
    0x6f,       0x6d,       0x6d,       0x65, 0x6e, 0x74, 0x0,  0x2e, 0x6e,
    0x6f,       0x74,       0x65,       0x2e, 0x47, 0x4e, 0x55, 0x2d, 0x73,
    0x74,       0x61,       0x63,       0x6b, 0x0,  0x2e, 0x6e, 0x6f, 0x74,
    0x65,       0x2e,       0x67,       0x6e, 0x75, 0x2e, 0x70, 0x72, 0x6f,
    0x70,       0x65,       0x72,       0x74, 0x79, 0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x1b, 0x0,
    0x0,        0x0,        0x1,        0x0,  0x0,  0x0,  0x6,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x40, 0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x1,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x21,
    0x0,        0x0,        0x0,        0x1,  0x0,  0x0,  0x0,  0x3,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x40, 0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x1,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x27,       0x0,        0x0,        0x0,  0x8,  0x0,  0x0,  0x0,  0x3,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x40, 0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x1,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x2c,       0x0,        0x0,  0x0,  0x1,  0x0,  0x0,  0x0,
    0x30,       0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x40, 0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x2b, 0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x1,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x1,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x35,       0x0,  0x0,  0x0,  0x1,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x6b,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x1,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x45, 0x0,  0x0,  0x0,  0x7,  0x0,
    0x0,        0x0,        0x2,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x70,       0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x20,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x8,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x1,  0x0,  0x0,  0x0,  0x2,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x90,       0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0xc0,       0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x8,
    0x0,        0x0,        0x0,        0x8,  0x0,  0x0,  0x0,  0x8,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x18, 0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x9,  0x0,  0x0,  0x0,
    0x3,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x50,       0x1,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x8,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x1,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x11, 0x0,  0x0,
    0x0,        0x3,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x58, 0x1,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x58,       0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x1,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0,        0x0,        0x0,  0x0,  0x0,  0x0};


/*
* The content of g_compile_data[] comes from hex dump of file foo.o,
* where foo.cu is a empty file. It comes from the following steps
* $gcc -xc foo.cu -c foo.o
* $hexdump foo.o
*
* foo.o is used to pass the check of compiler linker tool
*/
const unsigned char g_compile_data[] = {
    0x7F, 0x45, 0x4C, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x3E, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x68, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
    0x13, 0x00, 0x12, 0x00, 0xF3, 0x0F, 0x1E, 0xFA, 0x55, 0x48, 0x89, 0xE5,
    0x48, 0x89, 0x7D, 0xF8, 0x48, 0x8B, 0x45, 0xF8, 0x48, 0x89, 0x05, 0x00,
    0x00, 0x00, 0x00, 0x90, 0x5D, 0xC3, 0xF3, 0x0F, 0x1E, 0xFA, 0x55, 0x48,
    0x89, 0xE5, 0x48, 0x89, 0x7D, 0xF8, 0x48, 0x8B, 0x45, 0xF8, 0x48, 0x89,
    0x05, 0x00, 0x00, 0x00, 0x00, 0x90, 0x5D, 0xC3, 0xF3, 0x0F, 0x1E, 0xFA,
    0x55, 0x48, 0x89, 0xE5, 0x48, 0x8D, 0x3D, 0x00, 0x00, 0x00, 0x00, 0xE8,
    0xD2, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x05, 0x00, 0x00, 0x00, 0x00, 0x48,
    0x89, 0xC7, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x90, 0x5D, 0xC3, 0xF3, 0x0F,
    0x1E, 0xFA, 0x55, 0x48, 0x89, 0xE5, 0x48, 0x83, 0xEC, 0x10, 0x48, 0x89,
    0x7D, 0xF8, 0x48, 0x8B, 0x45, 0xF8, 0x48, 0x89, 0xC7, 0xE8, 0x00, 0x00,
    0x00, 0x00, 0xC9, 0xC3, 0xF3, 0x0F, 0x1E, 0xFA, 0x55, 0x48, 0x89, 0xE5,
    0x48, 0x83, 0xEC, 0x08, 0x48, 0x89, 0x7D, 0xF8, 0x48, 0x8B, 0x45, 0xF8,
    0x48, 0x89, 0x05, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x45, 0xF8, 0x48,
    0x89, 0xC7, 0xE8, 0x61, 0xFF, 0xFF, 0xFF, 0x90, 0xC9, 0xC3, 0xF3, 0x0F,
    0x1E, 0xFA, 0x55, 0x48, 0x89, 0xE5, 0x48, 0x83, 0xEC, 0x10, 0x48, 0x8D,
    0x3D, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x48, 0x89,
    0x05, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x05, 0xB0, 0xFF, 0xFF, 0xFF,
    0x48, 0x89, 0x45, 0xF8, 0x48, 0x8B, 0x05, 0x00, 0x00, 0x00, 0x00, 0x48,
    0x8B, 0x55, 0xF8, 0x48, 0x89, 0xC7, 0xFF, 0xD2, 0x48, 0x8B, 0x05, 0x00,
    0x00, 0x00, 0x00, 0x48, 0x89, 0xC7, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x48,
    0x8D, 0x3D, 0x42, 0xFF, 0xFF, 0xFF, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x90,
    0xC9, 0xC3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5F, 0x5F, 0x4E, 0x56,
    0x5F, 0x4D, 0x4F, 0x44, 0x55, 0x4C, 0x45, 0x5F, 0x49, 0x44, 0x00, 0x00,
    0x50, 0xED, 0x55, 0xBA, 0x01, 0x00, 0x10, 0x00, 0x78, 0x04, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x01, 0x40, 0x00, 0x00, 0x00,
    0xB8, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x01, 0x00, 0x34, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x45, 0x4C, 0x46,
    0x02, 0x01, 0x01, 0x33, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0xBE, 0x00, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x10, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xD0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x05, 0x34, 0x00,
    0x40, 0x00, 0x38, 0x00, 0x03, 0x00, 0x40, 0x00, 0x05, 0x00, 0x01, 0x00,
    0x00, 0x2E, 0x73, 0x68, 0x73, 0x74, 0x72, 0x74, 0x61, 0x62, 0x00, 0x2E,
    0x73, 0x74, 0x72, 0x74, 0x61, 0x62, 0x00, 0x2E, 0x73, 0x79, 0x6D, 0x74,
    0x61, 0x62, 0x00, 0x2E, 0x73, 0x79, 0x6D, 0x74, 0x61, 0x62, 0x5F, 0x73,
    0x68, 0x6E, 0x64, 0x78, 0x00, 0x2E, 0x6E, 0x76, 0x2E, 0x69, 0x6E, 0x66,
    0x6F, 0x00, 0x2E, 0x6E, 0x76, 0x2E, 0x72, 0x65, 0x6C, 0x2E, 0x61, 0x63,
    0x74, 0x69, 0x6F, 0x6E, 0x00, 0x00, 0x2E, 0x73, 0x68, 0x73, 0x74, 0x72,
    0x74, 0x61, 0x62, 0x00, 0x2E, 0x73, 0x74, 0x72, 0x74, 0x61, 0x62, 0x00,
    0x2E, 0x73, 0x79, 0x6D, 0x74, 0x61, 0x62, 0x00, 0x2E, 0x73, 0x79, 0x6D,
    0x74, 0x61, 0x62, 0x5F, 0x73, 0x68, 0x6E, 0x64, 0x78, 0x00, 0x2E, 0x6E,
    0x76, 0x2E, 0x69, 0x6E, 0x66, 0x6F, 0x00, 0x2E, 0x6E, 0x76, 0x2E, 0x72,
    0x65, 0x6C, 0x2E, 0x61, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x02, 0x02, 0x08, 0x10, 0x0A, 0x2F, 0x22, 0x00, 0x00, 0x00, 0x08,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x10, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x08,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x28, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x08,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x08, 0x08,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x10, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x18, 0x08, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x20, 0x08,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x28, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x30, 0x08, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x38, 0x08,
    0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x10, 0x08,
    0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x18, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x28, 0x08,
    0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x30, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x38, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14,
    0x2C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0B, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00,
    0x0B, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x06, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x10, 0x03, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA8, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x01, 0x01, 0x48, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x04, 0x00, 0x07, 0x00, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x11, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x13, 0x0A, 0x01, 0x00, 0xF0, 0x21, 0x2E, 0x76, 0x65, 0x72, 0x73, 0x69,
    0x6F, 0x6E, 0x20, 0x37, 0x2E, 0x34, 0x0A, 0x2E, 0x74, 0x61, 0x72, 0x67,
    0x65, 0x74, 0x20, 0x73, 0x6D, 0x5F, 0x35, 0x32, 0x0A, 0x2E, 0x61, 0x64,
    0x64, 0x72, 0x65, 0x73, 0x73, 0x5F, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x36,
    0x34, 0x0A, 0x0A, 0x0A, 0x0A, 0x00, 0x00, 0x00, 0xB1, 0x43, 0x62, 0x46,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x43, 0x43, 0x3A, 0x20, 0x28, 0x55,
    0x62, 0x75, 0x6E, 0x74, 0x75, 0x20, 0x39, 0x2E, 0x34, 0x2E, 0x30, 0x2D,
    0x31, 0x75, 0x62, 0x75, 0x6E, 0x74, 0x75, 0x31, 0x7E, 0x32, 0x30, 0x2E,
    0x30, 0x34, 0x2E, 0x31, 0x29, 0x20, 0x39, 0x2E, 0x34, 0x2E, 0x30, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
    0x05, 0x00, 0x00, 0x00, 0x47, 0x4E, 0x55, 0x00, 0x02, 0x00, 0x00, 0xC0,
    0x04, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7A, 0x52, 0x00,
    0x01, 0x78, 0x10, 0x01, 0x1B, 0x0C, 0x07, 0x08, 0x90, 0x01, 0x00, 0x00,
    0x1C, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x1A, 0x00, 0x00, 0x00, 0x00, 0x45, 0x0E, 0x10, 0x86, 0x02, 0x43, 0x0D,
    0x06, 0x51, 0x0C, 0x07, 0x08, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00,
    0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00,
    0x00, 0x45, 0x0E, 0x10, 0x86, 0x02, 0x43, 0x0D, 0x06, 0x51, 0x0C, 0x07,
    0x08, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x5C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00, 0x45, 0x0E, 0x10,
    0x86, 0x02, 0x43, 0x0D, 0x06, 0x5D, 0x0C, 0x07, 0x08, 0x00, 0x00, 0x00,
    0x1C, 0x00, 0x00, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x1E, 0x00, 0x00, 0x00, 0x00, 0x45, 0x0E, 0x10, 0x86, 0x02, 0x43, 0x0D,
    0x06, 0x55, 0x0C, 0x07, 0x08, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00,
    0x9C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00,
    0x00, 0x45, 0x0E, 0x10, 0x86, 0x02, 0x43, 0x0D, 0x06, 0x61, 0x0C, 0x07,
    0x08, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0xBC, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x00, 0x45, 0x0E, 0x10,
    0x86, 0x02, 0x43, 0x0D, 0x06, 0x02, 0x4F, 0x0C, 0x07, 0x08, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0xF1, 0xFF, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x2E, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x4A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x70, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x9E, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x10, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC4, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x1A, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xE2, 0x00, 0x00, 0x00, 0x01, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xF7, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x18, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x11, 0x01, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x34, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x32, 0x01, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x5A, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x5B, 0x01, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x66, 0x01, 0x00, 0x00, 0x01, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7B, 0x01, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x20, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xAB, 0x01, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x78, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xD3, 0x01, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0xA2, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xF2, 0x01, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x02, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x22, 0x02, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x33, 0x02, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x4B, 0x02, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x66, 0x02, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x74, 0x6D, 0x70, 0x78, 0x66, 0x74, 0x5F, 0x30, 0x30, 0x31, 0x34,
    0x35, 0x32, 0x63, 0x35, 0x5F, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
    0x30, 0x2D, 0x36, 0x5F, 0x65, 0x6D, 0x70, 0x74, 0x79, 0x2E, 0x63, 0x75,
    0x64, 0x61, 0x66, 0x65, 0x31, 0x2E, 0x63, 0x70, 0x70, 0x00, 0x5F, 0x5A,
    0x4C, 0x32, 0x32, 0x5F, 0x5F, 0x6E, 0x76, 0x5F, 0x69, 0x6E, 0x69, 0x74,
    0x65, 0x64, 0x5F, 0x6D, 0x61, 0x6E, 0x61, 0x67, 0x65, 0x64, 0x5F, 0x72,
    0x74, 0x00, 0x5F, 0x5A, 0x4C, 0x33, 0x32, 0x5F, 0x5F, 0x6E, 0x76, 0x5F,
    0x66, 0x61, 0x74, 0x62, 0x69, 0x6E, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65,
    0x5F, 0x66, 0x6F, 0x72, 0x5F, 0x6D, 0x61, 0x6E, 0x61, 0x67, 0x65, 0x64,
    0x5F, 0x72, 0x74, 0x00, 0x5F, 0x5A, 0x4C, 0x33, 0x37, 0x5F, 0x5F, 0x6E,
    0x76, 0x5F, 0x73, 0x61, 0x76, 0x65, 0x5F, 0x66, 0x61, 0x74, 0x62, 0x69,
    0x6E, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x5F, 0x66, 0x6F, 0x72, 0x5F,
    0x6D, 0x61, 0x6E, 0x61, 0x67, 0x65, 0x64, 0x5F, 0x72, 0x74, 0x50, 0x50,
    0x76, 0x00, 0x5F, 0x5A, 0x5A, 0x4C, 0x32, 0x32, 0x5F, 0x5F, 0x5F, 0x5F,
    0x6E, 0x76, 0x5F, 0x64, 0x75, 0x6D, 0x6D, 0x79, 0x5F, 0x70, 0x61, 0x72,
    0x61, 0x6D, 0x5F, 0x72, 0x65, 0x66, 0x50, 0x76, 0x45, 0x35, 0x5F, 0x5F,
    0x72, 0x65, 0x66, 0x00, 0x5F, 0x5A, 0x4C, 0x32, 0x32, 0x5F, 0x5F, 0x5F,
    0x5F, 0x6E, 0x76, 0x5F, 0x64, 0x75, 0x6D, 0x6D, 0x79, 0x5F, 0x70, 0x61,
    0x72, 0x61, 0x6D, 0x5F, 0x72, 0x65, 0x66, 0x50, 0x76, 0x00, 0x5F, 0x5A,
    0x4C, 0x31, 0x35, 0x5F, 0x5F, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x5F,
    0x69, 0x64, 0x5F, 0x73, 0x74, 0x72, 0x00, 0x5F, 0x5A, 0x4C, 0x32, 0x30,
    0x5F, 0x5F, 0x63, 0x75, 0x64, 0x61, 0x46, 0x61, 0x74, 0x43, 0x75, 0x62,
    0x69, 0x6E, 0x48, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x00, 0x5F, 0x5A, 0x4C,
    0x32, 0x36, 0x5F, 0x5F, 0x63, 0x75, 0x64, 0x61, 0x55, 0x6E, 0x72, 0x65,
    0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x42, 0x69, 0x6E, 0x61, 0x72, 0x79,
    0x55, 0x74, 0x69, 0x6C, 0x76, 0x00, 0x5F, 0x5A, 0x4C, 0x33, 0x32, 0x5F,
    0x5F, 0x6E, 0x76, 0x5F, 0x69, 0x6E, 0x69, 0x74, 0x5F, 0x6D, 0x61, 0x6E,
    0x61, 0x67, 0x65, 0x64, 0x5F, 0x72, 0x74, 0x5F, 0x77, 0x69, 0x74, 0x68,
    0x5F, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x50, 0x50, 0x76, 0x00, 0x66,
    0x61, 0x74, 0x62, 0x69, 0x6E, 0x44, 0x61, 0x74, 0x61, 0x00, 0x5F, 0x5A,
    0x4C, 0x31, 0x35, 0x5F, 0x5F, 0x66, 0x61, 0x74, 0x44, 0x65, 0x76, 0x69,
    0x63, 0x65, 0x54, 0x65, 0x78, 0x74, 0x00, 0x5F, 0x5A, 0x5A, 0x4C, 0x33,
    0x31, 0x5F, 0x5F, 0x6E, 0x76, 0x5F, 0x63, 0x75, 0x64, 0x61, 0x45, 0x6E,
    0x74, 0x69, 0x74, 0x79, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72,
    0x43, 0x61, 0x6C, 0x6C, 0x62, 0x61, 0x63, 0x6B, 0x50, 0x50, 0x76, 0x45,
    0x35, 0x5F, 0x5F, 0x72, 0x65, 0x66, 0x00, 0x5F, 0x5A, 0x4C, 0x33, 0x31,
    0x5F, 0x5F, 0x6E, 0x76, 0x5F, 0x63, 0x75, 0x64, 0x61, 0x45, 0x6E, 0x74,
    0x69, 0x74, 0x79, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x43,
    0x61, 0x6C, 0x6C, 0x62, 0x61, 0x63, 0x6B, 0x50, 0x50, 0x76, 0x00, 0x5F,
    0x5A, 0x4C, 0x32, 0x34, 0x5F, 0x5F, 0x73, 0x74, 0x69, 0x5F, 0x5F, 0x5F,
    0x5F, 0x63, 0x75, 0x64, 0x61, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65,
    0x72, 0x41, 0x6C, 0x6C, 0x76, 0x00, 0x5F, 0x47, 0x4C, 0x4F, 0x42, 0x41,
    0x4C, 0x5F, 0x4F, 0x46, 0x46, 0x53, 0x45, 0x54, 0x5F, 0x54, 0x41, 0x42,
    0x4C, 0x45, 0x5F, 0x00, 0x5F, 0x5F, 0x63, 0x75, 0x64, 0x61, 0x55, 0x6E,
    0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x46, 0x61, 0x74, 0x42,
    0x69, 0x6E, 0x61, 0x72, 0x79, 0x00, 0x5F, 0x5F, 0x63, 0x75, 0x64, 0x61,
    0x49, 0x6E, 0x69, 0x74, 0x4D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x00, 0x5F,
    0x5F, 0x63, 0x75, 0x64, 0x61, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65,
    0x72, 0x46, 0x61, 0x74, 0x42, 0x69, 0x6E, 0x61, 0x72, 0x79, 0x00, 0x5F,
    0x5F, 0x63, 0x75, 0x64, 0x61, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65,
    0x72, 0x46, 0x61, 0x74, 0x42, 0x69, 0x6E, 0x61, 0x72, 0x79, 0x45, 0x6E,
    0x64, 0x00, 0x61, 0x74, 0x65, 0x78, 0x69, 0x74, 0x00, 0x00, 0x00, 0x00,
    0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x2D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x04, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x04, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x4B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x04, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
    0x1C, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
    0x1D, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x04, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xB1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x11, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xB6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
    0x1E, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xBD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x04, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xCF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x04, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x04, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xE7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
    0x1F, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xF3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
    0x20, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00, 0xA2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00, 0xA2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x2E, 0x73, 0x79, 0x6D, 0x74, 0x61, 0x62, 0x00, 0x2E, 0x73, 0x74,
    0x72, 0x74, 0x61, 0x62, 0x00, 0x2E, 0x73, 0x68, 0x73, 0x74, 0x72, 0x74,
    0x61, 0x62, 0x00, 0x2E, 0x72, 0x65, 0x6C, 0x61, 0x2E, 0x74, 0x65, 0x78,
    0x74, 0x00, 0x2E, 0x64, 0x61, 0x74, 0x61, 0x00, 0x2E, 0x62, 0x73, 0x73,
    0x00, 0x5F, 0x5F, 0x6E, 0x76, 0x5F, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65,
    0x5F, 0x69, 0x64, 0x00, 0x2E, 0x6E, 0x76, 0x5F, 0x66, 0x61, 0x74, 0x62,
    0x69, 0x6E, 0x00, 0x2E, 0x72, 0x65, 0x6C, 0x61, 0x2E, 0x6E, 0x76, 0x46,
    0x61, 0x74, 0x42, 0x69, 0x6E, 0x53, 0x65, 0x67, 0x6D, 0x65, 0x6E, 0x74,
    0x00, 0x2E, 0x72, 0x65, 0x6C, 0x61, 0x2E, 0x69, 0x6E, 0x69, 0x74, 0x5F,
    0x61, 0x72, 0x72, 0x61, 0x79, 0x00, 0x2E, 0x63, 0x6F, 0x6D, 0x6D, 0x65,
    0x6E, 0x74, 0x00, 0x2E, 0x6E, 0x6F, 0x74, 0x65, 0x2E, 0x47, 0x4E, 0x55,
    0x2D, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x00, 0x2E, 0x6E, 0x6F, 0x74, 0x65,
    0x2E, 0x67, 0x6E, 0x75, 0x2E, 0x70, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74,
    0x79, 0x00, 0x2E, 0x72, 0x65, 0x6C, 0x61, 0x2E, 0x65, 0x68, 0x5F, 0x66,
    0x72, 0x61, 0x6D, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFA, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xA8, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x50, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3A, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x2C, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x88, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x50, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xD8, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xF8, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
    0x07, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x00,
    0x0E, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x05, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x61, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xF8, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x2C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7B, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x06, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x8B, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x28, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x48, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xD8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9E, 0x00, 0x00, 0x00,
    0x04, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x0E, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x03, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x00, 0x00,
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x38, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x6D, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB8, 0x0E, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xAD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

// This function is used to generate a fake file specified by \p filename.
// If ar_binary_used is zero, the content of file will be initialized by
// g_compile_data[]. If ar_binary_used is not zero, the content of file will be
// initialized by g_data[].
static int generate_file(char *filename, int ar_binary_used) {
  char buf[PATH_MAX];
  char cmd[PATH_MAX];
  int ret = 0;
  memset(cmd, '\0', PATH_MAX);
  memset(buf, '\0', PATH_MAX);
  int len = strlen(filename);
  // 10 is strlen of "mkdir -p  "
  if (len >= PATH_MAX - 10) {
    perror("bear: generate file fail.");
    return -1;
  }
  strncpy(buf, filename, len);
  buf[len] = '\0';
  while (len > 0) {
    if (buf[len] == '/') {
      buf[len] = '\0';
      sprintf(cmd, "mkdir -p %s ", buf);
      ret = system(cmd);
      break;
    }
    len--;
  }
  FILE *fd = fopen(filename, "w+");
  if (0 == fd) {
    perror("bear: generate_file fopen fail.");
    return -1;
  }
  if(ar_binary_used) {
    fwrite(g_data, 1, sizeof g_data, fd);
  } else {
    fwrite(g_compile_data, 1, sizeof g_compile_data, fd);
  }

  if (fclose(fd)) {
    perror("bear: fclose");
    return -1;
  }
  return ret;
}
int is_option_end(char *working) {
  return (isblank(working[0]) || working[0] == '\0');
}
// find xxx in "-o xxx"
// return value:
//  0 : found the project and create it.
//  1 : have not found the object, indicate next arg is object
//  -1: have not found the object.
int find_create_object(const char *str) {
  char *p = strstr(str, "-o");
  if (p && is_option_end(p + 2)) {
    p += 2;
    // skip empty
    while ((*p != '\0') && isblank(*p)) {
      p++;
    }
    if (*p == '\0') {
      return 1;
    }
    // find end of xxx.
    char *q = p;
    while (*q != '\0' && *q != ' ' && *q != '\t') {
      q++;
    }

    char ofilename[PATH_MAX];
    memset(ofilename, '\0', PATH_MAX);
    memcpy(ofilename, p, q - p);
    ofilename[q - p] = '\0';
    int ret = generate_file(ofilename, 0);
    return ret;
  }
  return -1;
}

// check if 1st field of str contains =
int is_contain_eq(char *working) {
  while (*working != '\0') {
    if (isblank(*working))
      break;
    if (*working == '=')
      return 1;
    working++;
  }
  return 0;
}
// skip empty space.
char *skip_empty(char *working) {
  if (working == NULL)
    return NULL;
  while (isblank(*working)) {
    working++;
  }
  return working;
}

// skip the option in "<option  value>"
char *skip_option(char *working) {
  if (working == NULL) {
    return NULL;
  }
  int len = strlen(working);
  while (len > 0) {
    len--;
    if (isblank(*working)) {
      working++;
      break;
    } else {
      working++;
    }
  }
  if (len == 0) {
    return NULL;
  }
  return working;
}
// skip the value in "<option  value>"
char *skip_value(char *working) {
  if (working == NULL) {
    return NULL;
  }
  int len = strlen(working);
  int require_quotation = 0;
  while (len > 0) {
    len--;
    // process "
    if (require_quotation && *working != '"') {
      working++;
      continue;
    } else if (require_quotation && *working == '"') {
      require_quotation = 0;
      working++;
      continue;
    }
    if (*working == '"') {
      working++;
      require_quotation = 1;
      continue;
    }
    //
    if (isblank(*working)) {
      working++;
      break;
    } else {
      working++;
    }
  }
  if (len == 0) {
    return NULL;
  }
  return working;
}
// check if string is end
int is_finished(char *working) {

  if (working == NULL || *working == '\0' || *working == '|')
    return 1;
  else
    return 0;
}
int is_kv_option_special(char *working) {
  if ((strncmp(working, "-D", 2) == 0 && !is_option_end(working + 2)) ||
      (strncmp(working, "-I", 2) == 0 && !is_option_end(working + 2)) ||
      (strncmp(working, "-O", 2) == 0 && !is_option_end(working + 2)) ||
      (strncmp(working, "-l", 2) == 0 && !is_option_end(working + 2))) {
    return 1;
  }
  return 0;
}
int is_single_option(char *working) {
  if (strncmp(working, "--version", 9) == 0 ||
      (strncmp(working, "-V", 2) == 0 && is_option_end(working + 2)) ||
      strncmp(working, "--help", 6) == 0 ||
      (strncmp(working, "-h", 2) == 0 && is_option_end(working + 2)) ||
      strncmp(working, "--no-compress", 13) == 0 ||
      strncmp(working, "-no-compress", 12) == 0 ||
      strncmp(working, "--extensible-whole-program", 26) == 0 ||
      strncmp(working, "-ewp", 4) == 0 ||
      strncmp(working, "--resource-usage", 16) == 0 ||
      strncmp(working, "-res-usage", 10) == 0 ||
      strncmp(working, "--Werror", 8) == 0 ||
      strncmp(working, "-Werror", 7) == 0 ||
      strncmp(working, "--Wno-deprecated-gpu-targets", 28) == 0 ||
      strncmp(working, "-Wno-deprecated-gpu-targets", 27) == 0 ||
      strncmp(working, "--Wno-deprecated-declarations", 29) == 0 ||
      strncmp(working, "-Wno-deprecated-declarations", 28) == 0 ||
      strncmp(working, "--Wreorder", 10) == 0 ||
      strncmp(working, "-Wreorder", 9) == 0 ||
      strncmp(working, "--restrict", 10) == 0 ||
      strncmp(working, "-restrict", 9) == 0 ||
      strncmp(working, "--source-in-ptx", 15) == 0 ||
      strncmp(working, "-src-in-ptx", 11) == 0 ||
      strncmp(working, "--keep-device-functions", 23) == 0 ||
      strncmp(working, "-keep-device-functions", 22) == 0 ||
      strncmp(working, "--disable-warnings", 18) == 0 ||
      (strncmp(working, "-w", 2) == 0 && is_option_end(working + 2)) ||
      strncmp(working, "--use_fast_math", 15) == 0 ||
      strncmp(working, "-use_fast_math", 14) == 0 ||
      strncmp(working, "--no-device-link", 16) == 0 ||
      strncmp(working, "-nodlink", 8) == 0 ||
      strncmp(working, "--no-align-double", 17) == 0 ||
      strncmp(working, "--no-align-double", 17) == 0 ||
      strncmp(working, "--clean-targets", 15) == 0 ||
      strncmp(working, "-clean", 6) == 0 ||
      strncmp(working, "--save-temps", 12) == 0 ||
      strncmp(working, "-save-temps", 11) == 0 ||
      strncmp(working, "--keep", 6) == 0 || strncmp(working, "-keep", 5) == 0 ||
      strncmp(working, "--verbose", 9) == 0 ||
      (strncmp(working, "-v", 2) == 0 && is_option_end(working + 2)) ||
      strncmp(working, "--dryrun", 8) == 0 ||
      strncmp(working, "-dryrun", 7) == 0 ||
      strncmp(working, "--dont-use-profile", 18) == 0 ||
      strncmp(working, "-noprof", 7) == 0 ||
      strncmp(working, "--expt-extended-lambda", 22) == 0 ||
      strncmp(working, "-expt-extended-lambda", 20) == 0 ||
      strncmp(working, "--expt-relaxed-constexpr", 24) == 0 ||
      strncmp(working, "-expt-relaxed-constexpr", 23) == 0 ||
      strncmp(working, "--no-host-device-move-forward", 29) == 0 ||
      strncmp(working, "-nohdmoveforward", 16) == 0 ||
      strncmp(working, "--no-host-device-initializer-list", 33) == 0 ||
      strncmp(working, "-nohdinitlist", 13) == 0 ||
      strncmp(working, "--shared", 8) == 0 ||
      strncmp(working, "-shared", 7) == 0 ||
      strncmp(working, "--generate-line-info", 20) == 0 ||
      strncmp(working, "-lineinfo", 9) == 0 ||
      strncmp(working, "--device-debug", 14) == 0 ||
      (strncmp(working, "-G", 2) == 0 && is_option_end(working + 2)) ||
      strncmp(working, "--debug", 7) == 0 ||
      (strncmp(working, "-g", 2) == 0 && is_option_end(working + 2)) ||
      strncmp(working, "--profile", 9) == 0 ||
      strncmp(working, "-pg", 3) == 0 ||
      strncmp(working, "--use-local-env", 15) == 0 ||
      strncmp(working, "--use-local-env", 15) == 0 ||
      strncmp(working, "--run", 5) == 0 || strncmp(working, "-run", 4) == 0 ||
      strncmp(working, "--lib", 5) == 0 || strncmp(working, "-lib", 4) == 0 ||
      strncmp(working, "--link", 6) == 0 || strncmp(working, "-link", 5) == 0 ||
      strncmp(working, "--device-link", 13) == 0 ||
      strncmp(working, "-dlink", 6) == 0 ||
      strncmp(working, "--device-w", 10) == 0 ||
      strncmp(working, "-dw", 3) == 0 ||
      strncmp(working, "--device-c", 10) == 0 ||
      strncmp(working, "-dc", 3) == 0 ||
      strncmp(working, "--compile", 9) == 0 ||
      (strncmp(working, "-c", 2) == 0 && is_option_end(working + 2)) ||
      strncmp(working, "--dependency-output", 19) == 0 ||
      strncmp(working, "-MF", 3) == 0 ||
      strncmp(working, "--generate-nonsystem-dependencies", 33) == 0 ||
      strncmp(working, "-MM", 3) == 0 ||
      strncmp(working, "--generate-dependencies", 23) == 0 ||
      (strncmp(working, "-M", 2) == 0 && is_option_end(working + 2)) ||
      strncmp(working, "--preprocess", 12) == 0 ||
      (strncmp(working, "-E", 2) == 0 && is_option_end(working + 2)) ||
      strncmp(working, "--ptx", 5) == 0 || strncmp(working, "-ptx", 4) == 0 ||
      strncmp(working, "--fatbin", 8) == 0 ||
      strncmp(working, "-fatbin", 7) == 0 ||
      strncmp(working, "--cubin", 7) == 0 ||
      strncmp(working, "-cubin", 6) == 0 ||
      strncmp(working, "--cuda", 6) == 0 || strncmp(working, "-cuda", 5) == 0) {
    return 1;
  }
  return 0;
}
int is_c_option(char *working) {
  if (strncmp(working, "--compile", 9) == 0 ||
      (strncmp(working, "-c", 2) == 0 && is_option_end(working + 2))) {
    return 1;
  } else {
    return 0;
  }
}

// Target to identify the inputfile in the command.
//   command: the command that be parsed.
//   c_found: return whether -c option is used.
//   inputfile: return the inputfile in the command.
int parse_input_file(char *command, int *c_found, char *inputfile) {
  // this function try to find the inputfile from command.
  // 1. must have -c|--compile option available.
  // 2. option format:
  //   <[-|--]option>
  //   <[-|--]option> <value>:  values may contains ", eg. "-O2 "
  //   <[-|--]option=value>
  // return: 1 if parse out input file.
  char *working = command;
  int ret = 0;
  // skip the exec-name
  working = skip_empty(working);
  working = skip_option(working);

  while (1) {
    working = skip_empty(working);
    if (is_finished(working)) {
      return ret;
    }
    // is option
    if (*working == '-') {
      // process options
      if (is_single_option(working) ||
          is_kv_option_special(working)) { // single option
        if (is_c_option(working)) {
          *c_found = 1;
        }
        working = skip_option(working);
        working = skip_empty(working);
        if (is_finished(working)) {
          return ret;
        }
      } else { // option=value
        if (is_contain_eq(working)) {
          working = skip_value(working);
          working = skip_empty(working);
        } else {
          // option,value
          working = skip_option(working);
          working = skip_empty(working);
          working = skip_value(working);
          working = skip_empty(working);
        }
        if (is_finished(working)) {
          return ret;
        }
      }
      continue;
    }
    // is input file.
    int len = 0;
    char *begin = working;
    while (*working != ' ' && *working != '\t' && *working != '\0') {
      working++;
      len++;
    }
    memcpy(inputfile, begin, len);
    ret = 1;

    working = skip_empty(working);
    if (is_finished(working)) {
      return ret;
    }
  }
  return ret;
}

// dump the command and options to the trace file which
// will be parsed by scripts in scan-build-py.
// '<option>' | 'file' are expected to write out to the fd.
// while for 'file ' and 'file )' need to remove the space and ).
void dump_US_field(const char *str, FILE *fd, int US, int has_parenthesis) {
  char *working = (char *)str;
  char *begin;
  working = skip_empty(working);

  if (working == NULL) {
    return;
  }

  char tmpbuf[PATH_MAX];
  memset(tmpbuf, '\0', PATH_MAX);
  begin = working;
  while (*working != '\0') {
    if (isblank(*working)) {
      memcpy(tmpbuf, begin, working - begin);
      tmpbuf[working - begin] = '\0';
      // remove the right ).
      if (has_parenthesis) {
        char *p = tmpbuf;
        while (*p != '\0') {
          if (*p == ')') {
            *p = '\0';
          }
          p++;
        }
      }
      fprintf(fd, "%s%c", tmpbuf, US);
      // skip the empty
      while (isblank(*working)) {
        working++;
      }
      if (*working == '\0') {
        return;
      }
      begin = working;
    } else {
      working++;
    }
  }
  memcpy(tmpbuf, begin, working - begin);
  tmpbuf[working - begin] = '\0';
  // remove the right ).
  if (has_parenthesis) {
    char *p = tmpbuf;
    while (*p != '\0') {
      if (*p == ')') {
        *p = '\0';
      }
      p++;
    }
  }
  fprintf(fd, "%s%c", tmpbuf, US);
  return;
}

#define COMPILER_ARRARY_SIZE 2
const char *find_compiler(const char *str, int *compiler_idx_ptr,
                          const char *const compiler_array[]) {
  const char *pos = NULL;
  for (int i = 0; i < COMPILER_ARRARY_SIZE; i++) {
    if (((pos = strstr(str, compiler_array[i])) != NULL)) {
      *compiler_idx_ptr = i;
      break;
    }
  }
  return pos;
}

const char *get_compiler(int compiler_idx, const char *const compiler_array[]) {
  return compiler_array[compiler_idx];
}

// Find compiler name in \p str, and return the position of the
// character behind the compiler name.
// e.g: str could be:
//      "/path/to/clang++  -Xcompiler ...",
//      "cd /home/user && /path/to/clang++  -ccbin=".
// returns the position of the character behind compiler in \p str,
// or NULL if no command "clang++" found in str.
const char *find_intercept_compiler(const char *str, int compiler_idx) {
  const char *pos = NULL;
  const char *ret = NULL;

  for (const char *ptr = str; *ptr != '\0'; ptr++) {
    if (isspace(*ptr)) {
      pos = ptr;

      int len = pos - str;
      if (compiler_idx == 0) {
        // nvcc
        if (len >= 4 && *(pos - 1) == 'c' && *(pos - 2) == 'c' &&
            *(pos - 3) == 'v' && *(pos - 4) == 'n') {
          ret = pos;
          return ret;
        }
      } else if (len >= 7 && *(pos - 1) == '+' && *(pos - 2) == '+' &&
                 *(pos - 3) == 'g' && *(pos - 4) == 'n' && *(pos - 5) == 'a' &&
                 *(pos - 6) == 'l' && *(pos - 7) == 'c') {
        // clang++
        ret = pos;
        return ret;
      }
    } else {
      continue;
    }
  }

  if (pos == NULL) {
    int len = strlen(str);
    if (compiler_idx == 0) {
      // nvcc
      if (len >= 4 && str[len - 1] == 'c' && str[len - 2] == 'c' &&
          str[len - 3] == 'v' && str[len - 4] == 'n') {
        ret = str + len;
        return ret;
      }
    } else if (len >= 7 && str[len - 1] == '+' && str[len - 2] == '+' &&
               str[len - 3] == 'g' && str[len - 4] == 'n' &&
               str[len - 5] == 'a' && str[len - 6] == 'l' &&
               str[len - 7] == 'g') {
      // clang++
      ret = str + len;
      return ret;
    }
  }

  return ret;
}

void emit_cmake_warning(char const *argv[], int argc) {
  const char *bin = argv[0];
  int len = strlen(bin);
  if ((len == 5 && bin[0] == 'e' && bin[1] == 'k' && bin[2] == 'a' &&
       bin[3] == 'm' && bin[4] == 'c') ||
      (len > 5 && bin[len - 6] == '/' && bin[len - 5] == 'c' &&
       bin[len - 4] == 'm') &&
          bin[len - 3] == 'a' && bin[len - 2] == 'k' && bin[len - 1] == 'e') {

    int find_make_directory = 0;
    for (size_t i = 0; i < argc; i++) {
      // if cmake runs with option "make_directory", like "/usr/bin/cmake  -E
      // make_directory  /path/to/build/_deps/foo-src", it means that cmake
      // configure is run in this directory.
      if (strcmp(argv[i], "make_directory") == 0) {
        find_make_directory = 1;
        break;
      }
    }

    static int print_once = 0;
    if (find_make_directory && !print_once) {
      perror(
          "[intercept-build: Error]: cmake is called to generate project build "
          "scripts when run \"intercept-build make\", the build scripts "
          "generated may not be complete. To generate a complete compilation "
          "database, suggest following steps:\n"
          "1. Build the source project by running \"make -B\" in build "
          "folder.\n"
          "2. Run \"intercept-build make -B\" to generate compilation database "
          "in build folder.\n");
    }
    print_once++;
  }
}

// Replace the command compiler with path to command "intercept-stub" with path.
// src could be:"/path/to/clang++",
//                 "/path/to/clang++ -Xcompiler ...",
//                 "CPATH=...;/path/to/clang++",
//                 "cd /path/to/dir && /path/to/clang++".
// pos Points to the position of the character behind compiler name
// compiler_idx Returned by find_compiler().
// compiler_array Compiler array.
// returns no return value.
char *replace_binary_name(const char *src, const char *pos, int compiler_idx,
                          const char *const compiler_array[]) {
  FILE *fp;
  char replacement[PATH_MAX];
  char file_path[PATH_MAX];

  fp = popen("which dpct", "r");
  if (fp == NULL) {
    perror("bear: failed to run command 'which dpct'\n");
    exit(EXIT_FAILURE);
  }

  if (fgets(replacement, PATH_MAX, fp) == NULL) {
    perror("bear: fgets\n");
    exit(EXIT_FAILURE);
  }
  pclose(fp);
  replacement[strlen(replacement) - 1] =
      '\0'; // to remove extra '\n' added by "which dpct"

  char *res = realpath(
      replacement,
      file_path); // to get the canonicalized absolute pathname in file_path

  if (!res) {
    perror("bear: realpath\n");
    exit(EXIT_FAILURE);
  }
  if ((strlen(file_path) + strlen("lib/libear/intercept-stub") -
       strlen("bin/dpct")) >= PATH_MAX) {
    perror("bear: strcpy overflow, path to dpct is too long.\n");
    exit(EXIT_FAILURE);
  }
  strcpy(file_path + strlen(file_path) - strlen("bin/dpct"),
         "lib/libear/intercept-stub");

  // To malloc required size of physical memory it really needs may fail in
  // some case, so malloc 4K bytes (one physical page) instead.
  char *buffer = (char *)malloc(4096);
  if (buffer == NULL) {
    perror("bear: malloc memory fail.");
    exit(EXIT_FAILURE);
  }

  char *insert_point = buffer;

  // To handle the situation that \psrc is
  // "CPATH=...;/path/to/clang++" and "cd /path/to/dir && /path/to/clang++"
  const char *pos_prefix =
      pos - strlen(get_compiler(compiler_idx, compiler_array));
  for (; pos_prefix != src; pos_prefix--) {
    if (*pos_prefix == ';' || *pos_prefix == '&') {
      pos_prefix++;
      break;
    }
  }

  int len = pos_prefix - src;
  memcpy(insert_point, src, len);
  insert_point += len;
  memcpy(insert_point, file_path, strlen(file_path));
  insert_point += strlen(file_path);
  src = pos;
  strcpy(insert_point, src);
  return buffer;
}

#endif // SYCLomatic_CUSTOMIZATION

/* this method is to write log about the process creation. */

#ifdef SYCLomatic_CUSTOMIZATION
// This method parses the command execution issued by the build tool make to
// write log for the compile options and fake the expecting outcome for the
// command. It returns whether intercept-stub is used to take over the command
// execution intercepted.
// true means intercept-stub is used to take over the command execution
// intercepted, false means intercept-stub is not used to take over the command
// execution intercepted.
static int bear_report_call(char const *fun, char const *argv[]) {
#else
static void bear_report_call(char const *fun, char const *const argv[]) {
#endif // SYCLomatic_CUSTOMIZATION
  static int const GS = 0x1d;
  static int const RS = 0x1e;
  static int const US = 0x1f;

  if (!initialized)
#ifdef SYCLomatic_CUSTOMIZATION
    initialized = bear_capture_env_t(&initial_env);
#else
    return;
#endif // SYCLomatic_CUSTOMIZATION

  pthread_mutex_lock(&mutex);
  const char *cwd = getcwd(NULL, 0);
  if (0 == cwd) {
    perror("bear: getcwd");
    pthread_mutex_unlock(&mutex);
    exit(EXIT_FAILURE);
  }
  char const *const out_dir = initial_env[0];
  size_t const path_max_length = strlen(out_dir) + 32;
  char filename[path_max_length];
  if (-1 ==
      snprintf(filename, path_max_length, "%s/%d.cmd", out_dir, getpid())) {
    perror("bear: snprintf");
    pthread_mutex_unlock(&mutex);
    exit(EXIT_FAILURE);
  }
  FILE *fd = fopen(filename, "a+");
  if (0 == fd) {
    perror("bear: fopen");
    pthread_mutex_unlock(&mutex);
    exit(EXIT_FAILURE);
  }
  fprintf(fd, "%d%c", getpid(), RS);
  fprintf(fd, "%d%c", getppid(), RS);
  fprintf(fd, "%s%c", fun, RS);
  fprintf(fd, "%s%c", cwd, RS);
  size_t const argc = bear_strings_length(argv);
#ifdef SYCLomatic_CUSTOMIZATION

  emit_cmake_warning(argv, argc);

  int is_file_found = 0;

  if(!access(argv[0], F_OK )){
    is_file_found = 1;
  }

  if (is_file_found) {
    for (size_t it = 0; it < argc; ++it) {
      fprintf(fd, "%s%c", argv[it], US);
    }
  } else {

    // compiler list should be intercepted.
    const char *const compiler_array[] = {"nvcc", "clang++"};
    // Current compiler index intercepted.
    int compiler_idx = 0;

    // To indicate whether the captured argv[i] is a compiler or ld command,
    // value: 1 yes, value 0 no.
    int is_nvcc_or_ld = 0;

    // To indicate whether the object file has been fake generated,
    // value: 1 obj file generated, value: 0 not generated.
    int flag_object = 0;

    // flag_optval is use for case: for options "-o xxx.o", "-o" and "xxx.o" is
    // in argv[i] and argv[i+1], if "-o" is found in argv[i], then flag_optval
    // is set to show argv[i+1] contains the xxx.o
    int flag_optval = 0;

    // value 1: means current command line is a compiler command, and the fake
    // obj file has been created, else ret is set to 0.
    int ret = 0;

    // To indicate whether the captured cmd is an ar static library command.
    int is_ar_staticlib_cmd = 0;

    const char *command_cp = NULL;
    size_t it_cp = 0;
    // (CPATH=;command  args), need remove () around the command
    int has_parenthesis = 0;

    // try to parse out compiler intercepted and generate obj_file.
    for (size_t it = 0; it < argc; ++it) {
      const char *tail = argv[it];
      int len = strlen(tail);
      const char *command = NULL;
      if (it <= 3 /*eg. /bin/bash -c [CPATH=xxx;]command*/ &&
          is_nvcc_or_ld == 0 &&
          ((command = find_compiler(tail, &compiler_idx, compiler_array)) !=
           NULL)) {
        command_cp = command;
        it_cp = it;
        is_nvcc_or_ld = 1;
        const char *tmpp = tail;
        while (tmpp != command) {
          if (*tmpp == '(') {
            has_parenthesis = 1;
            break;
          }
          tmpp++;
        }
        if (it == 0)
          fprintf(fd, "%s%c", "nvcc", US);
      } else if ((len == 2 && tail[0] == 'l' && tail[1] == 'd') ||
                 (len > 2 && tail[len - 3] == '/' && tail[len - 2] == 'l' &&
                  tail[len - 1] == 'd')) {
        is_nvcc_or_ld = 1;
        for (size_t i = it; i < argc; i++) {
          if (strcmp(argv[i], "-o") == 0) {
            char ofilename[PATH_MAX];
            int olen = strlen(argv[i + 1]);
            memset(ofilename, '\0', PATH_MAX);
            if (olen >= PATH_MAX) {
              perror("bear: filename length too long.");
              pthread_mutex_unlock(&mutex);
              exit(EXIT_FAILURE);
            }
            strncpy(ofilename, argv[i + 1], olen);
            if (generate_file(ofilename, 0) != 0) {
              pthread_mutex_unlock(&mutex);
              exit(EXIT_FAILURE);
            }
            flag_object = 1;
          }
        }
      } else if ((len == 2 && tail[0] == 'a' && tail[1] == 'r') ||
                 (len > 2 && tail[len - 3] == '/' && tail[len - 2] == 'a' &&
                  tail[len - 1] == 'r')) {
        is_nvcc_or_ld = 1;
        char ofilename[PATH_MAX];

        // The logic below to extract an archive name from an ar command, like:
        // 1. "/usr/bin/ar --plugin plugin.so -qc foo.a bar.o"
        // 2. "/usr/bin/ar qc foo.a bar.o "
        int is_option_plugin = 0;
        size_t idx = it + 1;
        for (; idx < argc; idx++) {
          if (strcmp(argv[idx], "--plugin") == 0) {
            is_option_plugin = 1;
          } else if (is_option_plugin) {
            is_option_plugin = 0;
            continue;
          } else {
            idx += 1;
            break; // To break the loop when idx points the archive name of ar
                   // command.
          }
        }
        int olen = strlen(argv[idx]);
        memset(ofilename, '\0', PATH_MAX);
        if (olen >= PATH_MAX) {
          perror("bear: filename length too long.");
          pthread_mutex_unlock(&mutex);
          exit(EXIT_FAILURE);
        }
        strncpy(ofilename, argv[idx], olen);
        if (generate_file(ofilename, 1) != 0) {
          pthread_mutex_unlock(&mutex);
          exit(EXIT_FAILURE);
        }
        flag_object = 1;
        is_ar_staticlib_cmd = 1;
      }

      if (flag_optval == 1) {
        char ofilename[PATH_MAX];
        int olen = strlen(argv[it]);
        memset(ofilename, '\0', PATH_MAX);
        if (olen >= PATH_MAX) {
          perror("bear: filename length too long.");
          pthread_mutex_unlock(&mutex);
          exit(EXIT_FAILURE);
        }
        strncpy(ofilename, argv[it], olen);
        if (generate_file(ofilename, 0) != 0) {
          pthread_mutex_unlock(&mutex);
          exit(EXIT_FAILURE);
        }
        flag_optval = 0;
        flag_object = 1;
      }
      if (flag_object == 0) {
        // here we need parse out the object file if -o option is used.
        // find xxx in the -o xxx of the command, generate it.
        int r = find_create_object(tail);
        if (r == 0) {
          flag_object = 1;
        }
        if (r == 1) {
          flag_optval = 1;
        }
      }
    }
    for (size_t it = it_cp; it < argc; ++it) {
      if (it == it_cp && command_cp != NULL) {
        dump_US_field(command_cp +
                          strlen(get_compiler(compiler_idx, compiler_array)),
                      fd, US, has_parenthesis);
      } else {
        dump_US_field(argv[it], fd, US, has_parenthesis);
      }
    }

    if (is_nvcc_or_ld == 1 && flag_object == 1) {
      ret = 1;
    } else if (is_nvcc_or_ld == 1) {
      // object is not given by -o. Need figure out the default output for cmd
      // "gcc -c xx.c"
      char *tmp = malloc(PATH_MAX);
      if (tmp == NULL) {
        perror("bear: malloc memory fail.");
        exit(EXIT_FAILURE);
      }
      memset(tmp, '\0', PATH_MAX);
      int idx = 0;
      int c_option;
      char ofilename[PATH_MAX];
      memset(ofilename, '\0', PATH_MAX);
      int parse_ret = 0;
      for (size_t it = it_cp; it < argc; ++it) {
        memcpy(tmp + idx, argv[it], strlen(argv[it]));
        idx += strlen(argv[it]);
        tmp[idx] = ' ';
        idx++;
      }
      parse_ret = parse_input_file(tmp, &c_option, ofilename);
      if (parse_ret == 1 && c_option == 1) {
        // change the suffix of the ofilename from .c .cpp => .o)
        int olen = strlen(ofilename);
        while (olen >= 0 && ofilename[olen] != '.') {
          olen--;
        }
        if (olen == -1) {
          olen = strlen(ofilename);
          if (olen >= PATH_MAX - 3) {
            perror("bear: filename length too long.");
            exit(EXIT_FAILURE);
          }
          ofilename[olen] = '.';
          ofilename[olen + 1] = 'o';
          ofilename[olen + 2] = '\0';
        } else {
          if (olen > PATH_MAX - 3) {
            perror("bear: filename length too long.");
            exit(EXIT_FAILURE);
          }
          ofilename[olen + 1] = 'o';
          ofilename[olen + 2] = '\0';
        }

        pthread_mutex_lock(&mutex);
        if (generate_file(ofilename, 0) != 0) {
          pthread_mutex_unlock(&mutex);
          exit(EXIT_FAILURE);
        }
        pthread_mutex_unlock(&mutex);
      }
      free(tmp);
      ret = 1;
    }

    // try to replace nvcc or clang++ with intercept-stub,
    // e.g: "/path/to/clang++ -ccbin ... ",
    //      "/bin/sh -c "/path/to"/bin/clang++ -ccbin ..."
    const char *pos = find_intercept_compiler(argv[it_cp], compiler_idx);

    int is_stub_need = 0;
    is_stub_need = (pos != NULL);
    if (is_stub_need) {
      ret = 0; // intercept-stub should continue to run.

      // intercept-stub is used to handle the compiler command like
      // "/bin/sh -c clang++ -c `echo ./`hello.c", it changes the compiler
      // command intercepted to
      // "/bin/sh -c /path/to/libear/intercept-stub -c `echo ./`hello.c", then
      // the coming command "/path/to/libear/intercept-stub -c ./hello.c" will
      // be run, and the source file name "hello.c" will be captured by
      // intercept.py.
      argv[it_cp] =
          replace_binary_name(argv[it_cp], pos, compiler_idx, compiler_array);
    }

    if (ret == 1 && it_cp == 0 && !is_ar_staticlib_cmd) {
      exit(0);
    }
    return is_stub_need;
  }
#else
  for (size_t it = 0; it < argc; ++it) {
    fprintf(fd, "%s%c", argv[it], US);
  }
#endif // SYCLomatic_CUSTOMIZATION
  fprintf(fd, "%c", GS);
  if (fclose(fd)) {
    perror("bear: fclose");
    pthread_mutex_unlock(&mutex);
    exit(EXIT_FAILURE);
  }
  free((void *)cwd);
  pthread_mutex_unlock(&mutex);
#ifdef SYCLomatic_CUSTOMIZATION
  if(is_file_found) {
    return 0;
  }
#endif // SYCLomatic_CUSTOMIZATION
}

/* update environment assure that children processes will copy the desired
 * behaviour */

static int bear_capture_env_t(bear_env_t *env) {
  int status = 1;
  for (size_t it = 0; it < ENV_SIZE; ++it) {
    char const *const env_value = getenv(env_names[it]);
    char const *const env_copy = (env_value) ? strdup(env_value) : env_value;
    (*env)[it] = env_copy;
    status &= (env_copy) ? 1 : 0;
  }
  return status;
}

static int bear_reset_env_t(bear_env_t *env) {
  int status = 1;
  for (size_t it = 0; it < ENV_SIZE; ++it) {
    if ((*env)[it]) {
      setenv(env_names[it], (*env)[it], 1);
    } else {
      unsetenv(env_names[it]);
    }
  }
  return status;
}

static void bear_release_env_t(bear_env_t *env) {
  for (size_t it = 0; it < ENV_SIZE; ++it) {
    free((void *)(*env)[it]);
    (*env)[it] = 0;
  }
}

static char const **bear_update_environment(char *const envp[],
                                            bear_env_t *env) {
  char const **result = bear_strings_copy((char const **)envp);
  for (size_t it = 0; it < ENV_SIZE && (*env)[it]; ++it)
    result = bear_update_environ(result, env_names[it], (*env)[it]);
  return result;
}

static char const **bear_update_environ(char const *envs[], char const *key,
                                        char const *const value) {
  // find the key if it's there
  size_t const key_length = strlen(key);
  char const **it = envs;
  for (; (it) && (*it); ++it) {
    if ((0 == strncmp(*it, key, key_length)) && (strlen(*it) > key_length) &&
        ('=' == (*it)[key_length]))
      break;
  }
  // allocate an environment entry
  size_t const value_length = strlen(value);
  size_t const env_length = key_length + value_length + 2;
  char *env = malloc(env_length);
  if (0 == env) {
    perror("bear: malloc [in env_update]");
    exit(EXIT_FAILURE);
  }
  if (-1 == snprintf(env, env_length, "%s=%s", key, value)) {
    perror("bear: snprintf");
    exit(EXIT_FAILURE);
  }
  // replace or append the environment entry
  if (it && *it) {
    free((void *)*it);
    *it = env;
    return envs;
  }
  return bear_strings_append(envs, env);
}

static char **bear_get_environment() {
#if defined HAVE_NSGETENVIRON
  return *_NSGetEnviron();
#else
  return environ;
#endif
}

/* util methods to deal with string arrays. environment and process arguments
 * are both represented as string arrays. */

static char const **bear_strings_build(char const *const arg, va_list *args) {
  char const **result = 0;
  size_t size = 0;
  for (char const *it = arg; it; it = va_arg(*args, char const *)) {
    result = realloc(result, (size + 1) * sizeof(char const *));
    if (0 == result) {
      perror("bear: realloc");
      exit(EXIT_FAILURE);
    }
    char const *copy = strdup(it);
    if (0 == copy) {
      perror("bear: strdup");
      exit(EXIT_FAILURE);
    }
    result[size++] = copy;
  }
  result = realloc(result, (size + 1) * sizeof(char const *));
  if (0 == result) {
    perror("bear: realloc");
    exit(EXIT_FAILURE);
  }
  result[size++] = 0;

  return result;
}

static char const **bear_strings_copy(char const **const in) {
  size_t const size = bear_strings_length(in);

  char const **const result = malloc((size + 1) * sizeof(char const *));
  if (0 == result) {
    perror("bear: malloc");
    exit(EXIT_FAILURE);
  }

  char const **out_it = result;
  for (char const *const *in_it = in; (in_it) && (*in_it); ++in_it, ++out_it) {
    *out_it = strdup(*in_it);
    if (0 == *out_it) {
      perror("bear: strdup");
      exit(EXIT_FAILURE);
    }
  }
  *out_it = 0;
  return result;
}

static char const **bear_strings_append(char const **const in,
                                        char const *const e) {
  size_t size = bear_strings_length(in);
  char const **result = realloc(in, (size + 2) * sizeof(char const *));
  if (0 == result) {
    perror("bear: realloc");
    exit(EXIT_FAILURE);
  }
  result[size++] = e;
  result[size++] = 0;
  return result;
}

static size_t bear_strings_length(char const *const *const in) {
  size_t result = 0;
  for (char const *const *it = in; (it) && (*it); ++it)
    ++result;
  return result;
}

static void bear_strings_release(char const **in) {
  for (char const *const *it = in; (it) && (*it); ++it) {
    free((void *)*it);
  }
  free((void *)in);
}
