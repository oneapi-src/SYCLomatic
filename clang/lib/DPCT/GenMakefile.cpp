//===--------------- GenMakefile.cpp --------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
#include "GenMakefile.h"
#include "AnalysisInfo.h"
#include "Diagnostics.h"
#include "SaveNewFiles.h"
#include "Utility.h"
#include "ValidateArguments.h"

#include "clang/Tooling/Refactoring.h"
#include "llvm/ADT/SmallString.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/Support/FileSystem.h"
#include "llvm/Support/Path.h"
#include "llvm/Support/raw_os_ostream.h"

#include <fstream>
#include <string>
#include <unordered_map>

using namespace clang::dpct;
using namespace llvm;

// Used to identify compilation commands without target
const std::string EmptyTarget = "NoLinker";

std::map<clang::tooling::UnifiedPath /*migrated file name*/, clang::tooling::CompilationInfo>
    CompileCmdsMap;

std::map<clang::tooling::UnifiedPath /*target*/, std::vector<clang::tooling::CompilationInfo>>
    CompileCmdsPerTarget;

std::vector<std::pair<clang::tooling::UnifiedPath /*original file name or linker entry*/,
                      std::vector<std::string> /*original compile command*/>>
    CompileTargetsMap;

static void fillCompileCmds(
    std::map<clang::tooling::UnifiedPath, std::vector<clang::tooling::CompilationInfo>>
        &CompileCmds,
    clang::tooling::CompilationInfo &CmpInfo, clang::tooling::UnifiedPath TargetName) {
  CompileCmds[TargetName].push_back(CmpInfo);
}

// To get customized basename from the file path.
// E.g: /path/to/foo.cc.cpp --> foo.cc
static std::string getCustomBaseName(const clang::tooling::UnifiedPath &Path) {
  std::string Filename = llvm::sys::path::filename(Path.getCanonicalPath()).str();
  std::size_t Pos = Filename.find_last_of('.');
  if (Pos != std::string::npos) {
    std::string BaseName = Filename.substr(0, Pos);
    return BaseName;
  }
  return Filename;
}

extern std::map<clang::tooling::UnifiedPath, bool> IncludeFileMap;

static void getCompileInfo(
    const clang::tooling::UnifiedPath& InRoot, const clang::tooling::UnifiedPath& OutRoot,
    std::map<clang::tooling::UnifiedPath, std::vector<clang::tooling::CompilationInfo>>
        &CompileCmds,
    std::unordered_map<clang::tooling::UnifiedPath, std::string> &ToolPerTarget) {

  std::unordered_map<clang::tooling::UnifiedPath, std::vector<std::string>>
      ObjsInLinkerCmdPerTarget;

  std::map<clang::tooling::UnifiedPath, clang::tooling::CompilationInfo> CmdsMap;

  for (const auto &Entry : CompileTargetsMap) {
    clang::tooling::UnifiedPath FileName = Entry.first;

    // Get value of key "directory" from compilation database
    const std::string Directory = Entry.second[0];

    if (path::filename(FileName.getCanonicalPath())
            .starts_with("LinkerEntry")) {
      // Parse linker cmd to get target name and objfile names
      std::vector<std::string> ObjsInLKOrARCmd;

      bool IsTargetName = false;
      bool IsArCommand = false;
      bool SkipArOptions = false;

      std::string TargetName;
      std::string Tool;

      // Collect all the targets generated by binary tool "ld" and "ar", also
      // the obj files that are related to each target.
      for (const auto &Obj : Entry.second) {
        if (Obj == "-o") {
          IsTargetName = true;
        } else if (IsTargetName) {
          // Set the target name
          TargetName = Obj;
          IsTargetName = false;
          Tool = "$(CC) -fsycl -o"; // use 'icpx -fsycl' to link the target file
                                    // in the generated Makefile.
        } else if (llvm::StringRef(Obj).ends_with(".o")) {
          clang::tooling::UnifiedPath FilePathAbs(Obj, Directory);
          ObjsInLKOrARCmd.push_back(
              std::string(FilePathAbs.getCanonicalPath()));
        } else if (Obj == "ar") {
          IsArCommand = true;
        } else if (IsArCommand) {
          SkipArOptions = true;
          IsArCommand = false;
        } else if (SkipArOptions) {
          TargetName = Obj;
          SkipArOptions = false;
          Tool = "ar -r"; // Record the tool that generates the target file.
        }
      }

      if (llvm::StringRef(TargetName).ends_with(".o") &&
          llvm::StringRef(Entry.second[1]).ends_with("nvcc")) {
        // Skip linker command like:
        // foo_generated_foo.cu.o ->foo_intermediate_link.o
        continue;
      }

      clang::tooling::UnifiedPath OutDirectory =
          dpct::appendPath(Directory, TargetName);
      // Use relative path to out-root directory.
      SmallString<512> OutDirectoryStr(OutDirectory.getCanonicalPath());
      llvm::sys::path::replace_path_prefix(OutDirectoryStr,
                                           InRoot.getCanonicalPath(), ".");
      TargetName = OutDirectoryStr.str().str();

      for (auto &Obj : ObjsInLKOrARCmd) {
        ObjsInLinkerCmdPerTarget[TargetName].push_back(Obj);
      }
      ToolPerTarget[TargetName] = Tool;
    } else {
      continue;
    }
  }

  std::unordered_map<clang::tooling::UnifiedPath /*origname*/,
                     clang::tooling::UnifiedPath /*objname*/>
      Orig2ObjMap;

  for (const auto &Entry : CompileTargetsMap) {
    clang::tooling::UnifiedPath FileName = Entry.first;

    if (path::filename(FileName.getCanonicalPath())
            .starts_with("LinkerEntry")) {
      continue;
    }

    std::string NewOptions;
    bool IsObjName = false;
    bool IsObjSpecified = false;

    // -isystem
    bool IsSystemInclude = false;

    // To parse option "-I <space> <path>"
    bool IsIncludeWithWhitespace = false;

    const std::string Directory = Entry.second[0];

    bool HasCudaSemantics = false;
    if (IncludeFileMap.count(FileName) && IncludeFileMap.at(FileName)) {
      HasCudaSemantics = true;
    }

    std::unordered_set<std::string> DuplicateDuplicateFilter;
    for (const auto &Option : Entry.second) {

      if (IsSystemInclude) {
        IsSystemInclude = false;
        clang::tooling::UnifiedPath IncPath = Option;
        rewriteDir(IncPath, InRoot, OutRoot);

        NewOptions += "-isystem ";
        SmallString<512> OutDirectory(IncPath.getCanonicalPath());
        llvm::sys::path::replace_path_prefix(OutDirectory,
                                             OutRoot.getCanonicalPath(), ".");
        NewOptions += OutDirectory.c_str();
        NewOptions += " ";
        continue;
      }

      if (IsIncludeWithWhitespace ||
          llvm::StringRef(Option).starts_with("-I")) {

        if (llvm::StringRef(Option).trim() == "-I") {
          IsIncludeWithWhitespace = true;
          continue;
        }

        // Parse include path specified by "-I"
        std::string IncPath = Option;
        if (!IsIncludeWithWhitespace) {
          IncPath = Option.substr(strlen("-I"));
          size_t Begin = IncPath.find_first_not_of(" ");
          IncPath = IncPath.substr(Begin);
        }

        IsIncludeWithWhitespace = false;
        if (!llvm::sys::fs::exists(IncPath)) {
          // Skip including path that does not exist.
          continue;
        }

        clang::tooling::UnifiedPath OutDirectory = IncPath;
        if (!isChildOrSamePath(InRoot, OutDirectory)) {
          // Skip include path that is not in inRoot directory
          continue;
        }

        NewOptions += "-I";

        // Use relative path to out-root directory as the including directory.
        SmallString<512> OutDirectoryStr(OutDirectory.getCanonicalPath());
        llvm::sys::path::replace_path_prefix(OutDirectoryStr,
                                             InRoot.getCanonicalPath(), ".");

        NewOptions += OutDirectoryStr.c_str();
        NewOptions += " ";

      } else if (llvm::StringRef(Option).starts_with("-isystem")) {
        IsSystemInclude = true;
      } else if (llvm::StringRef(Option).starts_with("-D")) {
        // Parse macros defined.
        std::size_t Len = Option.length() - strlen("-D");
        std::size_t Pos = Option.find("=");
        if (Pos != std::string::npos) {
          Len = Pos - strlen("-D");
        }
        std::string MacroName = Option.substr(strlen("-D"), Len);
        auto Iter = MapNames::MacroRuleMap.find(MacroName);
        if (Iter != MapNames::MacroRuleMap.end())
          // Skip macros defined in helper function header files
          continue;
        else
          NewOptions += Option + " ";
      } else if (llvm::StringRef(Option).starts_with("-std=")) {

        size_t Idx = 0;
        for (; Idx < Option.length(); Idx++) {
          if (std::isdigit(Option[Idx]))
            break;
        }
        auto Version = Option.substr(Idx, Option.length() - Idx);
        int Val = std::atoi(Version.c_str());

        // SYCL support c++17 as default.
        if (HasCudaSemantics && Val <= 17) {
          NewOptions += "-std=c++17 ";
          continue;
        }

        // Skip duplicate options.
        if (DuplicateDuplicateFilter.find(Option) !=
            end(DuplicateDuplicateFilter))
          continue;
        DuplicateDuplicateFilter.insert(Option);

        NewOptions += Option + " ";
      } else if (Option == "-o") {
        IsObjName = true;
        IsObjSpecified = true;
      } else if (IsObjName) {
        clang::tooling::UnifiedPath FilePathAbs(Option, Directory);
        Orig2ObjMap[FileName] = FilePathAbs;
        IsObjName = false;
      } else if (llvm::StringRef(Option).starts_with("-O")) {
        // Keep optimization level same as original compile command.
        NewOptions += Option + " ";
      } else if (Option == "-msse4.1" || Option == "-mavx512vl") {
        // Keep some options from original compile command.
        NewOptions += Option + " ";
      }
    }
    if (!IsObjSpecified) {
      // For the case that "-o" is not specified in the compile command, the
      // default obj file is generated in the directory where the compile
      // command runs.
      Orig2ObjMap[FileName] =
          dpct::appendPath(Directory, getCustomBaseName(FileName) + ".o");
    }

    // Add SYCL head file path to the including path in the generated Makefile
    // for source files which originally has CUDA Semantics and compiled by
    // non-nvcc compiler
    if (HasCudaSemantics &&
        !llvm::StringRef(Entry.second[1]).ends_with("nvcc")) {
      NewOptions += "-I $(INCLUDE_SYCL) ";
      NewOptions += "-I $(INCLUDE_CL) ";
    }

    auto OrigFileName = FileName;

    // rewriteFileName() should be called before rewriteDir(), as FileName
    // needs to be a existing file path passed to DpctFileInfo referred in
    // rewriteFileName() to avoid potential crash issue.
    rewriteFileName(FileName);
    rewriteDir(FileName, InRoot, OutRoot);

    if (llvm::sys::fs::exists(FileName.getCanonicalPath())) {
      SmallString<512> OutDirectory(FileName.getCanonicalPath());
      llvm::sys::path::replace_path_prefix(OutDirectory,
                                           OutRoot.getCanonicalPath(), ".");
      clang::tooling::CompilationInfo CmpInfo;
      CmpInfo.MigratedFileName = OutDirectory.c_str();
      CmpInfo.CompileOptions = NewOptions;
      CmpInfo.Compiler = Entry.second[1];
      CmdsMap[Orig2ObjMap[OrigFileName]] = CmpInfo;
    } else {
      SmallString<512> OutDirectory(OrigFileName.getCanonicalPath());
      llvm::sys::path::replace_path_prefix(OutDirectory,
                                           InRoot.getCanonicalPath(), ".");
      clang::tooling::CompilationInfo CmpInfo;
      CmpInfo.MigratedFileName = OutDirectory.c_str();
      CmpInfo.CompileOptions = NewOptions;
      CmpInfo.Compiler = Entry.second[1];
      CmdsMap[Orig2ObjMap[OrigFileName]] = CmpInfo;
    }
  }

  for (const auto &Entry : ObjsInLinkerCmdPerTarget) {
    for (const auto &Obj : Entry.second) {
      auto Iter = CmdsMap.find(Obj);
      if (Iter != CmdsMap.end()) {
        auto CmpInfo = Iter->second;
        fillCompileCmds(CompileCmds, CmpInfo, Entry.first);
      }
    }
  }

  if (ObjsInLinkerCmdPerTarget.empty()) {
    for (const auto &Cmd : CmdsMap) {
      auto CmpInfo = Cmd.second;
      fillCompileCmds(CompileCmds, CmpInfo, EmptyTarget);
    }
  }
}

static void genMakefile(
    clang::tooling::RefactoringTool &Tool, clang::tooling::UnifiedPath OutRoot,
    const std::string &BuildScriptName,
    std::map<clang::tooling::UnifiedPath,
             std::vector<clang::tooling::CompilationInfo>> &CmdsPerTarget,
    std::unordered_map<clang::tooling::UnifiedPath, std::string>
        &ToolPerTarget) {
  std::string Buf;
  llvm::raw_string_ostream OS(Buf);
  clang::tooling::UnifiedPath TargetName;

  OS << "CC := icpx\n\n";
  OS << "LD := $(CC)\n\n";
  OS << buildString(
      "#", DiagnosticsUtils::getMsgText(MakefileMsgs::GEN_MAKEFILE_LIB), "\n");
  OS << "LIB := \n\n";

  OS << buildString("FLAGS := \n\n");

  OS << buildString("ifeq ($(shell which $(CC)),)\n");
  OS << buildString("    $(error ERROR - $(CC) compiler not found)\n");
  OS << buildString("endif\n\n");

  OS << buildString("ROOT_DIR     := $(shell dirname $(shell which $(CC)))\n");
  OS << buildString("INCLUDE_SYCL := $(ROOT_DIR)/../include\n");
  OS << buildString("INCLUDE_CL   := $(ROOT_DIR)/../include/sycl\n\n");

  std::map<clang::tooling::UnifiedPath, std::string> ObjsPerTarget;

  std::map<std::string /*Source*/, std::string /*VariableName*/>
      SrcFilesBufferMap;
  std::map<std::string /*Object*/, std::string /*VariableName*/>
      ObjFilesBufferMap;
  std::map<std::string /*Flag*/, std::string /*VariableName*/> FlagsBufferMap;

  int TargetIdx = 0;
  for (const auto &Entry : CmdsPerTarget) {
    TargetName = Entry.first;

    auto Parent =
        dpct::appendPath(OutRoot.getCanonicalPath().str(),
                         path::parent_path(TargetName.getPath()).str());

    if (!llvm::sys::fs::exists(Parent)) {
      clang::dpct::createDirectories(Parent);
    }

    auto CmpInfos = Entry.second;
    int Count = 0;
    // Create compile commands for each source file
    for (const auto &CmpInfo : CmpInfos) {
      std::string MigratedFileName = CmpInfo.MigratedFileName;
      SmallString<512> MigratedName(MigratedFileName);

      SmallString<512> FilePath = StringRef(MigratedName);
      path::replace_extension(FilePath, "o");

      std::string SrcStrName = "TARGET_" + std::to_string(TargetIdx) + "_SRC_" +
                               std::to_string(Count);
      std::string ObjStrName = "TARGET_" + std::to_string(TargetIdx) + "_OBJ_" +
                               std::to_string(Count);
      std::string FlagStrName = "TARGET_" + std::to_string(TargetIdx) +
                                "_FLAG_" + std::to_string(Count);

      auto Iter = SrcFilesBufferMap.find(MigratedName.c_str());
      if (Iter != SrcFilesBufferMap.end()) {
        SrcStrName = SrcFilesBufferMap[MigratedName.c_str()];
        ObjStrName = ObjFilesBufferMap[FilePath.c_str()];
        FlagStrName = FlagsBufferMap[CmpInfo.CompileOptions.c_str()];
      } else {
        SrcFilesBufferMap[MigratedName.c_str()] = SrcStrName;
        ObjFilesBufferMap[FilePath.c_str()] = ObjStrName;
        FlagsBufferMap[CmpInfo.CompileOptions.c_str()] = FlagStrName;

        OS << buildString(SrcStrName, " = ", MigratedName, "\n");
        OS << buildString(ObjStrName, " = ", FilePath, "\n");
        OS << buildString(FlagStrName, " = ", CmpInfo.CompileOptions,
                          "${FLAGS}\n\n");

        Count++;
      }

      ObjsPerTarget[TargetName] +=
          buildString(" ${", buildString(ObjStrName), "}");
    }
    TargetIdx++;
  }

  std::string Target;
  std::string ObjStr;
  TargetIdx = 0;

  std::unordered_map<std::string /*TARGET*/, std::string /*ar or ld*/>
      ToolPerTargetVariable;
  for (const auto &Entry : CmdsPerTarget) {
    if (TargetName == EmptyTarget)
      continue;

    const std::string VarTarget =
        buildString("TARGET_", std::to_string(TargetIdx));

    OS << buildString(VarTarget, " := ", Entry.first.getPath(), "\n");
    ToolPerTargetVariable[VarTarget] = ToolPerTarget[Entry.first];
    Target += " " + buildString("${TARGET_", std::to_string(TargetIdx), "}");
    TargetIdx++;
  }

  if (!Tool.isInputfileSpecified() && TargetName != EmptyTarget) {
    OS << buildString("\nTARGET := ", Target, "\n\n");
  }
  OS << buildString(".PHONY:all clean\n");

  TargetIdx = 0;
  std::string AllObjs;
  for (const auto &Entry : CmdsPerTarget) {
    OS << buildString("OBJS_", std::to_string(TargetIdx),
                      " := ", ObjsPerTarget[Entry.first], "\n");
    AllObjs += buildString(" ${OBJS_", std::to_string(TargetIdx), "}");
    TargetIdx++;
  }

  if (Tool.isInputfileSpecified() || TargetName == EmptyTarget)
    OS << buildString("OBJS := ", AllObjs, "\n\n");

  if (Tool.isInputfileSpecified() || TargetName == EmptyTarget) {
    // For the case that target name is not available or input file(s) only
    // specified in command line, only compile command(s) generated in Makefile.
    OS << buildString("all: $(OBJS)\n\n");
    TargetIdx = 0;
    for (const auto &Entry : CmdsPerTarget) {

      for (unsigned Idx = 0; Idx < Entry.second.size(); Idx++) {

        SmallString<512> Source = StringRef(Entry.second[Idx].MigratedFileName);
        auto Option = Entry.second[Idx].CompileOptions;
        SmallString<512> Obj = StringRef(Source);
        path::replace_extension(Obj, "o");

        std::string SrcStrName = SrcFilesBufferMap[Source.c_str()];
        std::string ObjStrName = ObjFilesBufferMap[Obj.str().str()];
        std::string FlagStrName = FlagsBufferMap[Option];

        OS << buildString("$(", ObjStrName, "):$(", SrcStrName, ")\n");

        // Use 'icpx -fsycl' to compile all the migrated SYCL file.
        std::string Compiler = "$(CC) -fsycl";

        OS << buildString("\t", Compiler, " -c ${", SrcStrName, "} -o ${",
                          ObjStrName, "} $(", FlagStrName, ")\n\n");
      }
      TargetIdx++;
    }

  } else {
    std::string MKLOption = DpctGlobalInfo::isMKLHeaderUsed() ? "-qmkl" : "";
    OS << buildString("all: $(TARGET)\n");
    TargetIdx = 0;
    for (const auto &Entry : CmdsPerTarget) {
      OS << buildString("$(TARGET_", std::to_string(TargetIdx), "): $(OBJS_",
                        std::to_string(TargetIdx), ")\n");

      std::string Tool = ToolPerTargetVariable[buildString(
          "TARGET_", std::to_string(TargetIdx))];
      // Use to tool "ld" or "ar" that generates the original target in the
      // compilation database.
      if (Tool == "ar -r") { // "-qmkl" is not needed for "ar" target
        OS << buildString("\t", Tool, " $@ $^ $(LIB)\n\n");
      } else {
        OS << buildString("\t", Tool, " $@ $^ $(LIB) ", MKLOption, "\n\n");
      }

      for (unsigned Idx = 0; Idx < Entry.second.size(); Idx++) {

        SmallString<512> Source = StringRef(Entry.second[Idx].MigratedFileName);

        auto Option = Entry.second[Idx].CompileOptions;
        SmallString<512> Obj = StringRef(Source);
        path::replace_extension(Obj, "o");

        std::string SrcStrName = SrcFilesBufferMap[Source.c_str()];
        std::string ObjStrName = ObjFilesBufferMap[Obj.str().str()];
        std::string FlagStrName = FlagsBufferMap[Option];

        OS << buildString("$(", ObjStrName, "):$(", SrcStrName, ")\n");

        std::string Compiler = "$(CC) -fsycl";

        OS << buildString("\t", Compiler, " -c ${", SrcStrName, "} -o ${",
                          ObjStrName, "} $(", FlagStrName, ")\n\n");
      }
      TargetIdx++;
    }
  }

  OS << "clean:\n";
  if (!Tool.isInputfileSpecified() && TargetName != EmptyTarget)
    OS << buildString("\trm -f ", AllObjs, " $(TARGET)\n");
  else
    OS << buildString("\trm -f ", AllObjs, "\n");

  std::string FileOut =
      dpct::appendPath(OutRoot.getCanonicalPath().str(), BuildScriptName);
  writeDataToFile(FileOut, OS.str());
}

void genBuildScript(clang::tooling::RefactoringTool &Tool,
                    clang::tooling::UnifiedPath &InRoot,
                    clang::tooling::UnifiedPath &OutRoot,
                    const std::string &BuildScriptName) {
  std::map<clang::tooling::UnifiedPath /*traget name*/,
           std::vector<clang::tooling::CompilationInfo>>
      NewCompileCmdsMap;
  std::unordered_map<clang::tooling::UnifiedPath /*target*/,
                     std::string /*ar or ld*/>
      ToolPerTarget;

  getCompileInfo(InRoot, OutRoot, NewCompileCmdsMap, ToolPerTarget);

  bool NeedMergetYaml = false;

  const clang::tooling::UnifiedPath Target = EmptyTarget;

  // Increment compilation support only if input file(s) only specified in
  // command line
  auto Iter = NewCompileCmdsMap.find(Target);
  if (Iter != NewCompileCmdsMap.end()) {
    auto Iter = CompileCmdsPerTarget.find(Target);
    if (Iter != CompileCmdsPerTarget.end() || CompileCmdsPerTarget.empty()) {
      NeedMergetYaml = true;
    }
  }

  std::map<std::string, bool> DuplicateFilter;
  for (const auto &Entry : CompileCmdsPerTarget) {
    clang::tooling::UnifiedPath FileName = Entry.first;
    for (const auto &Option : Entry.second) {
      std::string Key = Entry.first.getCanonicalPath().str() +
                        Option.MigratedFileName + Option.CompileOptions +
                        Option.Compiler;
      DuplicateFilter[Key] = true;
    }
  }

  if (NeedMergetYaml) {
    for (const auto &Entry : NewCompileCmdsMap) {
      for (const auto &Option : Entry.second) {
        std::string Key = Entry.first.getCanonicalPath().str() +
                          Option.MigratedFileName + Option.CompileOptions +
                          Option.Compiler;
        auto Iter = DuplicateFilter.find(Key);
        if (Iter == DuplicateFilter.end()) {
          CompileCmdsPerTarget[Entry.first].push_back(Option);
        }
      }
    }
  }

  if (!NeedMergetYaml)
    CompileCmdsPerTarget = NewCompileCmdsMap;

  genMakefile(Tool, OutRoot, BuildScriptName, CompileCmdsPerTarget,
              ToolPerTarget);
}
