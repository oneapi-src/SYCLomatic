//===--------------- GenMakefile.cpp --------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
#include "GenMakefile.h"
#include "AnalysisInfo.h"
#include "Diagnostics.h"
#include "SaveNewFiles.h"
#include "ValidateArguments.h"

#include "llvm/ADT/SmallString.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/Support/FileSystem.h"
#include "llvm/Support/Path.h"

#include "clang/Tooling/Refactoring.h"

#include "llvm/Support/raw_os_ostream.h"
#include <fstream>
#include <unordered_map>

using namespace clang::dpct;
using namespace llvm;

// Used to identify compilation commands without target
const std::string EmptyTarget = "NoLinker";

std::map<std::string /*migrated file name*/, clang::tooling::CompilationInfo>
    CompileCmdsMap;

std::map<std::string /*target*/, std::vector<clang::tooling::CompilationInfo>>
    CompileCmdsPerTarget;

std::vector<std::pair<std::string /*original file name or linker entry*/,
                      std::vector<std::string> /*original compile command*/>>
    CompileTargetsMap;

static void fillCompileCmds(
    std::map<std::string, std::vector<clang::tooling::CompilationInfo>>
        &CompileCmds,
    clang::tooling::CompilationInfo &CmpInfo, std::string TargetName) {
  CompileCmds[TargetName].push_back(CmpInfo);
}

// To get customized basename from the file path.
// E.g: /path/to/foo.cc.cpp --> foo.cc
static std::string getCustomBaseName(const std::string &Path) {
  std::string Filename = llvm::sys::path::filename(Path).str();
  std::size_t Pos = Filename.find_last_of('.');
  if (Pos != std::string::npos) {
    std::string BaseName = Filename.substr(0, Pos);
    return BaseName;
  } else
    return Filename;
}

extern std::map<std::string, bool> IncludeFileMap;

static void getCompileInfo(
    StringRef InRoot, StringRef OutRoot,
    std::map<std::string, std::vector<clang::tooling::CompilationInfo>>
        &CompileCmds,
    std::unordered_map<std::string, std::string> &ToolPerTarget) {

  std::unordered_map<std::string, std::vector<std::string>>
      ObjsInLinkerCmdPerTarget;

  std::map<std::string, clang::tooling::CompilationInfo> CmdsMap;

  for (const auto &Entry : CompileTargetsMap) {
    std::string FileName = Entry.first;

    // Get value of key "directory" from compilation database
    const std::string Directory = Entry.second[0];

    if (llvm::StringRef(FileName).startswith("LinkerEntry")) {
      // Parse linker cmd to get target name and objfile names
      std::vector<std::string> ObjsInLKOrARCmd;

      bool IsTargetName = false;
      bool IsArCommand = false;
      bool SkipArOptions = false;

      std::string ObjName;
      std::string TargetName;
      std::string Tool;

      // Collect all the targets generated by binary tool "ld" and "ar", also
      // the obj files that are related to each target.
      for (const auto &Obj : Entry.second) {
        if (Obj == "-o") {
          IsTargetName = true;
        } else if (IsTargetName) {
          // Set the target name
          TargetName = Obj;
          IsTargetName = false;
          Tool = "$(CC) -fsycl -o"; // use 'icpx -fsycl' to link the target file in the
                             // generated Makefile.
        } else if (llvm::StringRef(Obj).endswith(".o")) {
          llvm::SmallString<512> FilePathAbs(Obj);

          if (!llvm::sys::path::is_absolute(Obj))
            FilePathAbs = Directory + "/" + Obj;

          makeCanonical(FilePathAbs);
          ObjsInLKOrARCmd.push_back(std::string(FilePathAbs.str()));
          ObjName = std::string(FilePathAbs.str());
        } else if (Obj == "ar") {
          IsArCommand = true;
        } else if (IsArCommand) {
          SkipArOptions = true;
          IsArCommand = false;
        } else if (SkipArOptions) {
          TargetName = Obj;
          SkipArOptions = false;
          Tool = "ar -r"; // Record the tool that generates the target file.
        }
      }

      if (llvm::StringRef(TargetName).endswith(".o") &&
          llvm::StringRef(Entry.second[1]).endswith("nvcc")) {
        // Skip linker command like:
        // foo_generated_foo.cu.o ->foo_intermediate_link.o
        continue;
      }

      for (auto &Obj : ObjsInLKOrARCmd) {
        ObjsInLinkerCmdPerTarget[TargetName].push_back(Obj);
      }
      ToolPerTarget[TargetName] = Tool;

    } else {
      continue;
    }
  }

  std::unordered_map<std::string /*origname*/, std::string /*objname*/>
      Orig2ObjMap;

  for (const auto &Entry : CompileTargetsMap) {
    std::string FileName = Entry.first;

    if (llvm::StringRef(FileName).startswith("LinkerEntry")) {
      continue;
    }

    std::string NewOptions;
    bool IsObjName = false;
    bool IsObjSpecified = false;

    // -isystem
    bool IsSystemInclude = false;

    // To parse option "-I <space> <path>"
    bool IsIncludeWithWhitespace = false;

    const std::string Directory = Entry.second[0];

    llvm::SmallString<512> RealPath;
    llvm::sys::fs::real_path(FileName, RealPath, true);
    if (!llvm::sys::path::is_absolute(FileName))
      RealPath = Directory + "/" + FileName;
    makeCanonical(RealPath);
    bool HasCudaSemantics = false;
    if (IncludeFileMap.count(std::string(RealPath.str())) &&
        IncludeFileMap.at(std::string(RealPath.str()))) {
      HasCudaSemantics = true;
    }

    std::unordered_set<std::string> DuplicateDuplicateFilter;
    for (const auto &Option : Entry.second) {

      if (IsSystemInclude) {
        IsSystemInclude = false;
        std::string IncPath = Option;

        SmallString<512> OutDirectory = llvm::StringRef(IncPath);
        llvm::sys::fs::make_absolute(OutDirectory);
        llvm::sys::path::remove_dots(OutDirectory, /*remove_dot_dot=*/true);
        makeCanonical(OutDirectory);

        rewriteDir(OutDirectory, InRoot, OutRoot);

        NewOptions += "-isystem ";
        llvm::sys::path::replace_path_prefix(OutDirectory, OutRoot, ".");
        NewOptions += OutDirectory.c_str();
        NewOptions += " ";
        continue;
      }

      if (IsIncludeWithWhitespace || llvm::StringRef(Option).startswith("-I")) {

        if (llvm::StringRef(Option).trim() == "-I") {
          IsIncludeWithWhitespace = true;
          continue;
        }

        // Parse include path specified by "-I"
        std::string IncPath = Option;
        if (!IsIncludeWithWhitespace) {
          IncPath = Option.substr(strlen("-I"));
          size_t Begin = IncPath.find_first_not_of(" ");
          IncPath = IncPath.substr(Begin);
        }

        IsIncludeWithWhitespace = false;

        if (!llvm::sys::fs::exists(IncPath)) {
          // Skip including path that does not exist.
          continue;
        }

        SmallString<512> OutDirectory = llvm::StringRef(IncPath);
        llvm::sys::fs::make_absolute(OutDirectory);
        llvm::sys::path::remove_dots(OutDirectory, /*remove_dot_dot=*/true);
        makeCanonical(OutDirectory);

        if (!isChildPath(InRoot.str(), std::string(OutDirectory.c_str()),
                         false)) {
          // Skip include path that is not in inRoot directory
          continue;
        }

        rewriteDir(OutDirectory, InRoot, OutRoot);

        NewOptions += "-I";
        llvm::sys::path::replace_path_prefix(OutDirectory, OutRoot, ".");
        NewOptions += OutDirectory.c_str();
        NewOptions += " ";

      } else if (llvm::StringRef(Option).startswith("-isystem")) {
        IsSystemInclude = true;
      } else if (llvm::StringRef(Option).startswith("-D")) {
        // Parse macros defined.
        std::size_t Len = Option.length() - strlen("-D");
        std::size_t Pos = Option.find("=");
        if (Pos != std::string::npos) {
          Len = Pos - strlen("-D");
        }
        std::string MacroName = Option.substr(strlen("-D"), Len);
        auto Iter = MapNames::MacrosMap.find(MacroName);
        if (Iter != MapNames::MacrosMap.end())
          // Skip macros defined in helper function header files
          continue;
        else
          NewOptions += Option + " ";
      } else if (llvm::StringRef(Option).startswith("-std=")) {

        size_t Idx = 0;
        for (; Idx < Option.length(); Idx++) {
          if (std::isdigit(Option[Idx]))
            break;
        }
        auto Version = Option.substr(Idx, Option.length() - Idx);
        int Val = std::atoi(Version.c_str());

        // SYCL support c++17 as default.
        if (HasCudaSemantics && Val <= 17) {
          NewOptions += "-std=c++17 ";
          continue;
        }

        // Skip duplicate options.
        if (DuplicateDuplicateFilter.find(Option) !=
            end(DuplicateDuplicateFilter))
          continue;
        DuplicateDuplicateFilter.insert(Option);

        NewOptions += Option + " ";
      } else if (Option == "-o") {
        IsObjName = true;
        IsObjSpecified = true;
      } else if (IsObjName) {
        llvm::SmallString<512> FilePathAbs(Option);

        if (!llvm::sys::path::is_absolute(Option))
          FilePathAbs = Directory + "/" + Option;

        makeCanonical(FilePathAbs);
        Orig2ObjMap[FileName] = std::string(FilePathAbs.str());
        IsObjName = false;
      } else if (llvm::StringRef(Option).startswith("-O")) {
        // Keep optimization level same as original compile command.
        NewOptions += Option + " ";
      } else if (Option == "-msse4.1" || Option == "-mavx512vl") {
        // Keep some options from original compile command.
        NewOptions += Option + " ";
      }
    }
    if (!IsObjSpecified) {
      // For the case that "-o" is not specified in the compile command, the
      // default obj file is generated in the directory where the compile
      // command runs.
      Orig2ObjMap[FileName] =
          Directory + "/" + getCustomBaseName(FileName) + ".o";
    }

    // if option "--use-custom-helper=<value>" is used to customize the helper
    // header files for migrated code, the path of the helper header files
    // should be included.
    if (llvm::sys::fs::exists(OutRoot.str() + "/include")) {
      NewOptions += "-I ./include ";
    }

    // Add SYCL head file path to the including path in the generated Makefile
    // for source files which originally has CUDA Semantics and compiled by
    // non-nvcc compiler
    if (HasCudaSemantics &&
        !llvm::StringRef(Entry.second[1]).endswith("nvcc")) {
      NewOptions += "-I $(INCLUDE_SYCL) ";
      NewOptions += "-I $(INCLUDE_CL) ";
    }

    SmallString<512> OutDirectory = llvm::StringRef(FileName);
    makeCanonical(OutDirectory);
    rewriteDir(OutDirectory, InRoot, OutRoot);
    auto OrigFileName = OutDirectory;
    rewriteFileName(OutDirectory);

    if (llvm::sys::fs::exists(OutDirectory)) {
      llvm::sys::path::replace_path_prefix(OutDirectory, OutRoot, ".");
      clang::tooling::CompilationInfo CmpInfo;
      CmpInfo.MigratedFileName = OutDirectory.c_str();
      CmpInfo.CompileOptions = NewOptions;
      CmpInfo.Compiler = Entry.second[1];
      CmdsMap[Orig2ObjMap[FileName]] = CmpInfo;
    } else {
      llvm::sys::path::replace_path_prefix(OrigFileName, OutRoot, ".");
      clang::tooling::CompilationInfo CmpInfo;
      CmpInfo.MigratedFileName = OrigFileName.c_str();
      CmpInfo.CompileOptions = NewOptions;
      CmpInfo.Compiler = Entry.second[1];
      CmdsMap[Orig2ObjMap[FileName]] = CmpInfo;
    }
  }

  for (const auto &Entry : ObjsInLinkerCmdPerTarget) {
    for (const auto &Obj : Entry.second) {

      auto Iter = CmdsMap.find(Obj);
      if (Iter != CmdsMap.end()) {
        auto CmpInfo = Iter->second;
        fillCompileCmds(CompileCmds, CmpInfo, Entry.first);
      }
    }
  }

  if (ObjsInLinkerCmdPerTarget.empty()) {
    for (const auto &Cmd : CmdsMap) {
      auto CmpInfo = Cmd.second;
      fillCompileCmds(CompileCmds, CmpInfo, EmptyTarget);
    }
  }
}

static void
genMakefile(clang::tooling::RefactoringTool &Tool, StringRef OutRoot,
            const std::string &BuildScriptName,
            std::map<std::string, std::vector<clang::tooling::CompilationInfo>>
                &CmdsPerTarget,
            std::unordered_map<std::string, std::string> &ToolPerTarget) {
  std::string Buf;
  llvm::raw_string_ostream OS(Buf);
  std::string TargetName;

  OS << "CC := icpx\n\n";
  OS << "LD := $(CC)\n\n";
  OS << buildString(
      "#", DiagnosticsUtils::getMsgText(MakefileMsgs::GEN_MAKEFILE_LIB), "\n");
  OS << "LIB := \n\n";

  OS << buildString("FLAGS := \n\n");

  OS << buildString("ifeq ($(shell which $(CC)),)\n");
  OS << buildString("    $(error ERROR - $(CC) compiler not found)\n");
  OS << buildString("endif\n\n");

  OS << buildString("ROOT_DIR     := $(shell dirname $(shell which $(CC)))\n");
  OS << buildString("INCLUDE_SYCL := $(ROOT_DIR)/../include\n");
  OS << buildString("INCLUDE_CL   := $(ROOT_DIR)/../include/sycl\n\n");

  std::map<std::string, std::string> ObjsPerTarget;

  int TargetIdx = 0;
  for (const auto &Entry : CmdsPerTarget) {
    TargetName = Entry.first;
    SmallString<512> TargetFilePath =
        llvm::StringRef(OutRoot.str() + "/" + TargetName);
    auto Parent = path::parent_path(TargetFilePath);

    if (!llvm::sys::fs::exists(Parent)) {
      std::error_code EC;
      EC = llvm::sys::fs::create_directories(Parent);
      if ((bool)EC) {
        std::string ErrMsg =
            "[ERROR] Create Directory : " + std::string(Parent.str()) +
            " fail: " + EC.message() + "\n";
        PrintMsg(ErrMsg);
      }
    }

    auto CmpInfos = Entry.second;
    int Count = 0;
    for (const auto &CmpInfo : CmpInfos) {
      const auto &MigratedName = CmpInfo.MigratedFileName;

      std::string SrcStrName = "TARGET_" + std::to_string(TargetIdx) + "_SRC_" +
                               std::to_string(Count);
      std::string ObjStrName = "TARGET_" + std::to_string(TargetIdx) + "_OBJ_" +
                               std::to_string(Count);
      std::string FlagStrName = "TARGET_" + std::to_string(TargetIdx) +
                                "_FLAG_" + std::to_string(Count);
      OS << buildString(SrcStrName, " = ", MigratedName, "\n");
      SmallString<512> FilePath = StringRef(MigratedName);
      path::replace_extension(FilePath, "o");
      OS << buildString(ObjStrName, " = ", FilePath, "\n");
      OS << buildString(FlagStrName, " = ", CmpInfo.CompileOptions,
                        "${FLAGS}\n\n");

      ObjsPerTarget[TargetName] +=
          buildString(" ${", buildString(ObjStrName), "}");
      Count++;
    }
    TargetIdx++;
  }

  std::string Target;
  std::string ObjStr;
  TargetIdx = 0;

  std::unordered_map<std::string /*TARGET*/, std::string /*ar or ld*/>
      ToolPerTargetVariable;
  for (const auto &Entry : CmdsPerTarget) {
    if (TargetName == EmptyTarget)
      continue;

    const std::string VarTarget =
        buildString("TARGET_", std::to_string(TargetIdx));

    OS << buildString(VarTarget, " := ", Entry.first, "\n");
    ToolPerTargetVariable[VarTarget] = ToolPerTarget[Entry.first];
    Target += " " + buildString("${TARGET_", std::to_string(TargetIdx), "}");
    TargetIdx++;
  }

  if (!Tool.isInputfileSpecified() && TargetName != EmptyTarget) {
    OS << buildString("\nTARGET := ", Target, "\n\n");
  }
  OS << buildString(".PHONY:all clean\n");

  TargetIdx = 0;
  std::string AllObjs;
  for (const auto &Entry : CmdsPerTarget) {
    OS << buildString("OBJS_", std::to_string(TargetIdx),
                      " := ", ObjsPerTarget[Entry.first], "\n");
    AllObjs += buildString(" ${OBJS_", std::to_string(TargetIdx), "}");
    TargetIdx++;
  }

  if (Tool.isInputfileSpecified() || TargetName == EmptyTarget)
    OS << buildString("OBJS := ", AllObjs, "\n\n");

  if (Tool.isInputfileSpecified() || TargetName == EmptyTarget) {
    // For the case that target name is not available or input file(s) only
    // specified in command line, only compile command(s) generated in Makefile.
    OS << buildString("all: $(OBJS)\n\n");
    TargetIdx = 0;
    for (const auto &Entry : CmdsPerTarget) {

      for (unsigned Idx = 0; Idx < Entry.second.size(); Idx++) {
        std::string SrcStrName = "TARGET_" + std::to_string(TargetIdx) +
                                 "_SRC_" + std::to_string(Idx);
        std::string ObjStrName = "TARGET_" + std::to_string(TargetIdx) +
                                 "_OBJ_" + std::to_string(Idx);
        std::string FlagStrName = "TARGET_" + std::to_string(TargetIdx) +
                                  "_FLAG_" + std::to_string(Idx);
        OS << buildString("$(", ObjStrName, "):$(", SrcStrName, ")\n");

        // Use 'icpx -fsycl' to compile the migrated SYCL file.
        std::string Compiler =
            llvm::StringRef((Entry.second)[Idx].Compiler).endswith("nvcc")
                ? "$(CC) -fsycl"
                : (Entry.second)[Idx].Compiler;

        OS << buildString("\t", Compiler, " -c ${", SrcStrName, "} -o ${",
                          ObjStrName, "} $(", FlagStrName, ")\n\n");
      }
      TargetIdx++;
    }

  } else {
    std::string MKLOption = DpctGlobalInfo::isMKLHeaderUsed() ? "-qmkl" : "";
    OS << buildString("all: $(TARGET)\n");
    TargetIdx = 0;
    for (const auto &Entry : CmdsPerTarget) {
      OS << buildString("$(TARGET_", std::to_string(TargetIdx), "): $(OBJS_",
                        std::to_string(TargetIdx), ")\n");

      std::string Tool = ToolPerTargetVariable[buildString(
          "TARGET_", std::to_string(TargetIdx))];
      // Use to tool "ld" or "ar" that generates the original target in the
      // compilation database.
      OS << buildString("\t", Tool, " $@ $^ $(LIB) ", MKLOption, "\n\n");

      for (unsigned Idx = 0; Idx < Entry.second.size(); Idx++) {
        std::string SrcStrName = "TARGET_" + std::to_string(TargetIdx) +
                                 "_SRC_" + std::to_string(Idx);
        std::string ObjStrName = "TARGET_" + std::to_string(TargetIdx) +
                                 "_OBJ_" + std::to_string(Idx);
        std::string FlagStrName = "TARGET_" + std::to_string(TargetIdx) +
                                  "_FLAG_" + std::to_string(Idx);
        OS << buildString("$(", ObjStrName, "):$(", SrcStrName, ")\n");

        std::string Compiler =
            llvm::StringRef((Entry.second)[Idx].Compiler).endswith("nvcc")
                ? "$(CC) -fsycl"
                : (Entry.second)[Idx].Compiler;

        OS << buildString("\t", Compiler, " -c ${", SrcStrName, "} -o ${",
                          ObjStrName, "} $(", FlagStrName, ")\n\n");
      }
      TargetIdx++;
    }
  }

  OS << "clean:\n";
  if (!Tool.isInputfileSpecified() && TargetName != EmptyTarget)
    OS << buildString("\trm -f ", AllObjs, " $(TARGET)\n");
  else
    OS << buildString("\trm -f ", AllObjs, "\n");

  std::string FileOut = OutRoot.str() + "/" + BuildScriptName;
  std::ofstream File;
  File.open(FileOut, std::ios::binary);
  if (File) {
    File << OS.str();
    File.close();
  }
}

void genBuildScript(clang::tooling::RefactoringTool &Tool, StringRef InRoot,
                    StringRef OutRoot, const std::string &BuildScriptName) {

  std::map<std::string /*traget name*/,
           std::vector<clang::tooling::CompilationInfo>>
      NewCompileCmdsMap;

  std::unordered_map<std::string /*target*/, std::string /*ar or ld*/>
      ToolPerTarget;

  getCompileInfo(InRoot, OutRoot, NewCompileCmdsMap, ToolPerTarget);

  bool NeedMergetYaml = false;

  const std::string Target = EmptyTarget;

  // Increment compilation support only if input file(s) only specified in
  // command line
  auto Iter = NewCompileCmdsMap.find(Target);
  if (Iter != NewCompileCmdsMap.end()) {
    auto Iter = CompileCmdsPerTarget.find(Target);
    if (Iter != CompileCmdsPerTarget.end() || CompileCmdsPerTarget.empty()) {
      NeedMergetYaml = true;
    }
  }

  std::map<std::string, bool> DuplicateFilter;
  for (const auto &Entry : CompileCmdsPerTarget) {
    std::string FileName = Entry.first;
    for (const auto &Option : Entry.second) {
      std::string Key = Entry.first + Option.MigratedFileName +
                        Option.CompileOptions + Option.Compiler;
      DuplicateFilter[Key] = true;
    }
  }

  if (NeedMergetYaml) {
    for (const auto &Entry : NewCompileCmdsMap) {
      for (const auto &Option : Entry.second) {
        std::string Key = Entry.first + Option.MigratedFileName +
                          Option.CompileOptions + Option.Compiler;
        auto Iter = DuplicateFilter.find(Key);
        if (Iter == DuplicateFilter.end()) {
          CompileCmdsPerTarget[Entry.first].push_back(Option);
        }
      }
    }
  }

  if (!NeedMergetYaml)
    CompileCmdsPerTarget = NewCompileCmdsMap;

  genMakefile(Tool, OutRoot, BuildScriptName, CompileCmdsPerTarget,
              ToolPerTarget);
}
