.. _id_DPCT1104:

DPCT1104
========

Message
-------

.. _msg-1104-start:

``<expression text>`` should point to a dynamic library loaded in memory. The dynamic
library should supply "wrapped" kernel functions.

.. _msg-1104-end:

Detailed Help
-------------

The CUDA application expects ``<expression text>`` to point to a CUDA module whose file
image has been copied to memory. The user should ensure that the CUDA code that generated
the CUDA module is migrated to SYCL code, compiled to generate a kernel library, and then
copied to memory by the migrated SYCL application.

Suggestions to Fix
------------------

The user should find the module source file(s) that are used to make the CUDA module and
migrate the module source file(s) to SYCL with the --extra-arg=--ptx option of the
compatibility tool to generate wrapped kernel functions:

.. code-block:: bash
   :linenos:

   dpct <module source file(s)> --extra-arg=--ptx

The migrated module source file(s) should be compiled to build a kernel library.
On Linux:

.. code-block:: bash
   :linenos:

   icpx -fsycl <migrated module source file(s)> -fPIC -shared -o <kernel library filename>

On Windows:

.. code-block:: bash
   :linenos:

   icpx -fsycl <migrated module source file(s)> -shared -o <kernel library filename>

The user should ensure that the application will load the kernel library image into
memory at runtime. For the following example this can be ensured by setting
``<kernel library filename>`` to "module.ptx".

Example:

Original code:

.. code-block:: cpp
   :linenos:

   const void *image = copyFileToMemory("module.ptx");
   cuModuleLoadData(&module, image);

Migrated code:

.. code-block:: cpp
   :linenos:

   const void *image = copyFileToMemory("module.ptx");
   module = dpct::load_kernel_library(image);
