.. _DPCT1103:

DPCT1103
========

Message
-------

.. _msg-1103-start:

``<expression text>`` should be a dynamic library. The dynamic library should supply
wrapped kernel functions.

.. _msg-1103-end:

Detailed Help
-------------

The CUDA\* application expects ``<expression text>`` to be the name of a CUDA module.
The user should ensure that the CUDA code that generated the CUDA module is migrated
to SYCL\* code and compiled to generate a kernel library.

Suggestions to Fix
------------------

The user should find the module source files that are used to make the CUDA module
and migrate them to SYCL using the ``--extra-arg=-ptx`` option of |tool_name|
to generate wrapped kernel functions:

.. code-block:: bash

   dpct <module source file(s)> --extra-arg=--ptx

The migrated module source file(s) should be compiled to make a kernel library.

On Linux\*:

.. code-block:: bash

   icpx -fsycl <migrated module source file(s)> -fPIC -shared -o <kernel library filename>

On Windows\*:

.. code-block:: bash

   icpx -fsycl <migrated module source file(s)> -shared -o <kernel library filename>

The ``<kernel library filename>`` should be chosen so that ``<expression text>`` will have
the same filename at runtime. For the following example, ``<kernel library filename>`` should
be set to ``library.so``.

For example, this original CUDA code:

.. code-block:: cpp
   :linenos:

     char *ptxFile = "module.ptx";
     cuModuleLoad(&module, ptxFile);

results in the following migrated SYCL code:

.. code-block:: cpp
   :linenos:

     char *ptxFile = "module.ptx";
     module = dpct::load_kernel_library(ptxFile);

which is rewritten to:

.. code-block:: cpp
   :linenos:

     char *libraryFile = "library.so";
     module = dpct::load_kernel_library(libraryFile);
