.. _DPCT1103:

DPCT1103
========

Message
-------

.. _msg-1103-start:

*<expression text>* should be a dynamic library. The dynamic library should supply
wrapped kernel functions.

.. _msg-1103-end:

Detailed Help
-------------

The CUDA\* application expects *<expression text>* to be the name of a CUDA module.
The user should ensure that the CUDA code that generated the CUDA module is migrated
to SYCL\* code and compiled to generate a kernel library.

Suggestions to Fix
------------------

The user should find the module source files that are used to make the CUDA module
and migrate them to SYCL using the ``--extra-arg=-ptx`` option of |tool_name|
to generate wrapped kernel functions:

.. code-block:: bash

   dpct <module source file(s)> --extra-arg=--ptx

The migrated module source file(s) should be compiled to make a kernel library.

On Linux\*:

.. code-block:: bash

   icpx -fsycl <migrated module source file(s)> -fPIC -shared -o <kernel library filename>

On Windows\*:

.. code-block:: bash

   icpx -fsycl <migrated module source file(s)> -shared -o <kernel library filename>

The *<kernel library filename>* should be chosen so that *<expression text>* will have
the same filename at runtime. For the following example, *<kernel library filename>* should
be set to ``library.so``.

For example, this original CUDA code:

.. code-block:: cpp
   :linenos:

     char *ptxFile = "module.ptx";
     cuModuleLoad(&module, ptxFile);

results in the following migrated SYCL code:

.. code-block:: cpp
   :linenos:

     char *ptxFile = "module.ptx";
     module = dpct::load_kernel_library(ptxFile);

which is rewritten to:

.. code-block:: cpp
   :linenos:

     char *libraryFile = "library.so";
     module = dpct::load_kernel_library(libraryFile);
